1592536606
3 3
12 libp3collide 4 dlaq 12 panda3d.core 
253
265 20 get_collision_origin 0 6 518 36 CollisionSolid::get_collision_origin 0 1 1 0
69
virtual LPoint3 CollisionSolid::get_collision_origin(void) const = 0;

266 12 set_tangible 0 4 518 28 CollisionSolid::set_tangible 0 1 2 295
/**
 * Sets the current state of the 'tangible' flag.  Set this true to make the
 * solid tangible, so that a CollisionHandlerPusher will not allow another
 * object to intersect it, or false to make it intangible, so that a
 * CollisionHandlerPusher will ignore it except to throw an event.
 */
56
inline void CollisionSolid::set_tangible(bool tangible);

267 11 is_tangible 0 4 518 27 CollisionSolid::is_tangible 0 1 3 266
/**
 * Returns whether the solid is considered 'tangible' or not.  An intangible
 * solid has no effect in a CollisionHandlerPusher (except to throw an event);
 * it's useful for defining 'trigger' planes and spheres, that cause an effect
 * when passed through.
 */
52
inline bool CollisionSolid::is_tangible(void) const;

268 20 set_effective_normal 0 4 518 36 CollisionSolid::set_effective_normal 0 1 4 388
/**
 * Records a false normal for this CollisionSolid that will be reported by the
 * collision system with all collisions into it, instead of its actual normal.
 * This is useful as a workaround for the problem of an avatar wanting to
 * stand on a sloping ground; by storing a false normal, the ground appears to
 * be perfectly level, and the avatar does not tend to slide down it.
 */
83
inline void CollisionSolid::set_effective_normal(LVector3 const &effective_normal);

269 22 clear_effective_normal 0 4 518 38 CollisionSolid::clear_effective_normal 0 1 5 71
/**
 * Removes the normal previously set by set_effective_normal().
 */
57
inline void CollisionSolid::clear_effective_normal(void);

270 20 has_effective_normal 0 4 518 36 CollisionSolid::has_effective_normal 0 1 6 98
/**
 * Returns true if a special normal was set by set_effective_normal(), false
 * otherwise.
 */
61
inline bool CollisionSolid::has_effective_normal(void) const;

271 20 get_effective_normal 0 4 518 36 CollisionSolid::get_effective_normal 0 1 7 145
/**
 * Returns the normal that was set by set_effective_normal().  It is an error
 * to call this unless has_effective_normal() returns true.
 */
72
inline LVector3 const &CollisionSolid::get_effective_normal(void) const;

272 28 set_respect_effective_normal 0 4 518 44 CollisionSolid::set_respect_effective_normal 0 1 8 296
/**
 * This is only meaningful for CollisionSolids that will be added to a
 * traverser as colliders.  It is normally true, but if set false, it means
 * that this particular solid does not care about the "effective" normal of
 * other solids it meets, but rather always uses the true normal.
 */
88
inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal);

273 28 get_respect_effective_normal 0 4 518 44 CollisionSolid::get_respect_effective_normal 0 1 9 46
/**
 * See set_respect_effective_normal().
 */
69
inline bool CollisionSolid::get_respect_effective_normal(void) const;

274 10 get_bounds 0 4 518 26 CollisionSolid::get_bounds 0 1 10 47
/**
 * Returns the solid's bounding volume.
 */
72
ConstPointerTo< BoundingVolume > CollisionSolid::get_bounds(void) const;

275 10 set_bounds 0 4 518 26 CollisionSolid::set_bounds 0 1 11 47
/**
 * Returns the solid's bounding volume.
 */
71
void CollisionSolid::set_bounds(BoundingVolume const &bounding_volume);

276 6 output 0 6 518 22 CollisionSolid::output 0 1 12 10
/**
 *
 */
61
virtual void CollisionSolid::output(std::ostream &out) const;

277 5 write 0 6 518 21 CollisionSolid::write 0 1 13 10
/**
 *
 */
82
virtual void CollisionSolid::write(std::ostream &out, int indent_level = 0) const;

278 14 get_class_type 0 4 518 30 CollisionSolid::get_class_type 0 1 14 0
55
static TypeHandle CollisionSolid::get_class_type(void);

279 12 CollisionBox 0 4 524 26 CollisionBox::CollisionBox 0 2 15 16 256
/**
 * Create the Box by giving a Center and distances of each of the sides of
 * box from the Center.
 */

/**
 * Create the Box by Specifying the Diagonal Points
 */

/**
 * Creates an invalid Box.  Only used when reading from a bam file.
 */

/**
 *
 */
195
inline explicit CollisionBox::CollisionBox(LPoint3 const &center, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
inline explicit CollisionBox::CollisionBox(LPoint3 const &min, LPoint3 const &max);

280 14 get_num_points 0 4 524 28 CollisionBox::get_num_points 0 1 17 68
/**
 * Returns 8: the number of vertices of a rectangular solid.
 */
52
inline int CollisionBox::get_num_points(void) const;

281 14 get_point_aabb 0 4 524 28 CollisionBox::get_point_aabb 0 1 18 67
/**
 * Returns the nth vertex of the Axis Aligned Bounding Box.
 */
57
inline LPoint3 CollisionBox::get_point_aabb(int n) const;

282 9 get_point 0 4 524 23 CollisionBox::get_point 0 1 19 45
/**
 * Returns the nth vertex of the OBB.
 */
52
inline LPoint3 CollisionBox::get_point(int n) const;

283 14 get_num_planes 0 4 524 28 CollisionBox::get_num_planes 0 1 20 65
/**
 * Returns 6: the number of faces of a rectangular solid.
 */
52
inline int CollisionBox::get_num_planes(void) const;

284 9 set_plane 0 4 524 23 CollisionBox::set_plane 0 1 21 57
/**
 * Creates the nth face of the rectangular solid.
 */
51
inline LPlane CollisionBox::set_plane(int n) const;

285 9 get_plane 0 4 524 23 CollisionBox::get_plane 0 1 22 57
/**
 * Returns the nth face of the rectangular solid.
 */
51
inline LPlane CollisionBox::get_plane(int n) const;

286 10 set_center 0 4 524 24 CollisionBox::set_center 0 2 23 24 22
/**
 *
 */

/**
 *
 */
143
inline void CollisionBox::set_center(LPoint3 const &center);
inline void CollisionBox::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

287 10 get_center 0 4 524 24 CollisionBox::get_center 0 1 25 10
/**
 *
 */
59
inline LPoint3 const &CollisionBox::get_center(void) const;

288 7 get_min 0 4 524 21 CollisionBox::get_min 0 1 26 10
/**
 *
 */
56
inline LPoint3 const &CollisionBox::get_min(void) const;

289 7 get_max 0 4 524 21 CollisionBox::get_max 0 1 27 10
/**
 *
 */
56
inline LPoint3 const &CollisionBox::get_max(void) const;

290 14 get_dimensions 0 4 524 28 CollisionBox::get_dimensions 0 1 28 10
/**
 *
 */
57
inline LVector3 CollisionBox::get_dimensions(void) const;

291 14 get_class_type 0 4 524 28 CollisionBox::get_class_type 0 1 29 0
53
static TypeHandle CollisionBox::get_class_type(void);

292 13 ~CollisionBox 0 4 524 27 CollisionBox::~CollisionBox 0 0 0
34
CollisionBox::~CollisionBox(void);

293 16 CollisionCapsule 0 4 528 34 CollisionCapsule::CollisionCapsule 0 2 30 31 115
/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid capsule.  Only used when reading from a bam file.
 */

/**
 *
 */
276
inline explicit CollisionCapsule::CollisionCapsule(LPoint3 const &a, LPoint3 const &db, PN_stdfloat radius);
inline explicit CollisionCapsule::CollisionCapsule(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz, PN_stdfloat radius);

294 11 set_point_a 0 4 528 29 CollisionCapsule::set_point_a 0 2 32 33 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionCapsule::set_point_a(LPoint3 const &a);
inline void CollisionCapsule::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

295 11 get_point_a 0 4 528 29 CollisionCapsule::get_point_a 0 1 34 10
/**
 *
 */
64
inline LPoint3 const &CollisionCapsule::get_point_a(void) const;

296 11 set_point_b 0 4 528 29 CollisionCapsule::set_point_b 0 2 35 36 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionCapsule::set_point_b(LPoint3 const &b);
inline void CollisionCapsule::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

297 11 get_point_b 0 4 528 29 CollisionCapsule::get_point_b 0 1 37 10
/**
 *
 */
64
inline LPoint3 const &CollisionCapsule::get_point_b(void) const;

298 10 set_radius 0 4 528 28 CollisionCapsule::set_radius 0 1 38 10
/**
 *
 */
61
inline void CollisionCapsule::set_radius(PN_stdfloat radius);

299 10 get_radius 0 4 528 28 CollisionCapsule::get_radius 0 1 39 10
/**
 *
 */
60
inline PN_stdfloat CollisionCapsule::get_radius(void) const;

300 14 get_class_type 0 4 528 32 CollisionCapsule::get_class_type 0 1 40 0
57
static TypeHandle CollisionCapsule::get_class_type(void);

301 17 ~CollisionCapsule 0 4 528 35 CollisionCapsule::~CollisionCapsule 0 0 0
42
CollisionCapsule::~CollisionCapsule(void);

302 14 get_class_type 0 4 531 32 CollisionHandler::get_class_type 0 1 42 0
57
static TypeHandle CollisionHandler::get_class_type(void);

303 16 CollisionHandler 0 4 531 34 CollisionHandler::CollisionHandler 0 1 41 10
/**
 *
 */
78
inline CollisionHandler::CollisionHandler(CollisionHandler const &) = default;

304 17 ~CollisionHandler 0 4 531 35 CollisionHandler::~CollisionHandler 0 0 0
42
CollisionHandler::~CollisionHandler(void);

305 13 CollisionNode 0 4 533 28 CollisionNode::CollisionNode 0 1 43 22
/**
 *
 */

/**
 *
 */
63
explicit CollisionNode::CollisionNode(std::string const &name);

306 16 set_collide_mask 0 4 533 31 CollisionNode::set_collide_mask 0 1 44 98
/**
 * Simultaneously sets both the "from" and "into" CollideMask values to the
 * same thing.
 */
62
inline void CollisionNode::set_collide_mask(CollideMask mask);

307 21 set_from_collide_mask 0 4 533 36 CollisionNode::set_from_collide_mask 0 1 45 222
/**
 * Sets the "from" CollideMask.  In order for a collision to be detected from
 * this object into another object, the intersection of this object's "from"
 * mask and the other object's "into" mask must be nonzero.
 */
60
void CollisionNode::set_from_collide_mask(CollideMask mask);

308 21 set_into_collide_mask 0 4 533 36 CollisionNode::set_into_collide_mask 0 1 46 222
/**
 * Sets the "into" CollideMask.  In order for a collision to be detected from
 * another object into this object, the intersection of the other object's
 * "from" mask and this object's "into" mask must be nonzero.
 */
67
inline void CollisionNode::set_into_collide_mask(CollideMask mask);

309 21 get_from_collide_mask 0 4 533 36 CollisionNode::get_from_collide_mask 0 1 47 233
/**
 * Returns the current "from" CollideMask.  In order for a collision to be
 * detected from this object into another object, the intersection of this
 * object's "from" mask and the other object's "into" mask must be nonzero.
 */
68
inline CollideMask CollisionNode::get_from_collide_mask(void) const;

310 21 get_into_collide_mask 0 4 533 36 CollisionNode::get_into_collide_mask 0 1 48 233
/**
 * Returns the current "into" CollideMask.  In order for a collision to be
 * detected from another object into this object, the intersection of the
 * other object's "from" mask and this object's "into" mask must be nonzero.
 */
68
inline CollideMask CollisionNode::get_into_collide_mask(void) const;

311 12 clear_solids 0 4 533 27 CollisionNode::clear_solids 0 1 49 44
/**
 * Removes all solids from the node.
 */
46
inline void CollisionNode::clear_solids(void);

312 14 get_num_solids 0 4 533 29 CollisionNode::get_num_solids 0 1 50 10
/**
 *
 */
61
inline std::size_t CollisionNode::get_num_solids(void) const;

313 9 get_solid 0 4 533 24 CollisionNode::get_solid 0 1 51 10
/**
 *
 */
86
inline ConstPointerTo< CollisionSolid > CollisionNode::get_solid(std::size_t n) const;

314 12 modify_solid 0 4 533 27 CollisionNode::modify_solid 0 1 52 10
/**
 *
 */
78
inline PointerTo< CollisionSolid > CollisionNode::modify_solid(std::size_t n);

315 9 set_solid 0 4 533 24 CollisionNode::set_solid 0 1 53 55
/**
 * Replaces the solid with the indicated index.
 */
75
inline void CollisionNode::set_solid(std::size_t n, CollisionSolid *solid);

316 12 insert_solid 0 4 533 27 CollisionNode::insert_solid 0 1 54 77
/**
 * Inserts the indicated solid to the node at the indicated position.
 */
84
inline void CollisionNode::insert_solid(std::size_t n, CollisionSolid const *solid);

317 12 remove_solid 0 4 533 27 CollisionNode::remove_solid 0 1 55 110
/**
 * Removes the solid with the indicated index.  This will shift all subsequent
 * indices down by one.
 */
55
inline void CollisionNode::remove_solid(std::size_t n);

318 9 add_solid 0 4 533 24 CollisionNode::add_solid 0 1 56 121
/**
 * Adds the indicated solid to the node.  Returns the index of the new solid
 * within the node's list of solids.
 */
73
inline std::size_t CollisionNode::add_solid(CollisionSolid const *solid);

319 17 get_collider_sort 0 4 533 32 CollisionNode::get_collider_sort 0 1 57 114
/**
 * Returns the collider_sort value that has been set for this particular node.
 * See set_collider_sort().
 */
56
inline int CollisionNode::get_collider_sort(void) const;

320 17 set_collider_sort 0 4 533 32 CollisionNode::set_collider_sort 0 1 58 594
/**
 * Sets a particular collider_sort value on this node.  This controls the
 * order in which colliders (that is, "from nodes") are grouped together for
 * the collision traversal.
 *
 * If there are 32 or fewer colliders added to any particular
 * CollisionTraverser, then this value has no meaning.  It is only useful if
 * there are many colliders, which may force the CollisionTraverser to make
 * multiple passes through the data; in that case, it may be a useful
 * optimization to group colliders that have similar bounding volumes together
 * (by giving them similar sort values).
 */
55
inline void CollisionNode::set_collider_sort(int sort);

321 24 get_default_collide_mask 0 4 533 39 CollisionNode::get_default_collide_mask 0 1 59 80
/**
 * Returns the default into_collide_mask assigned to new CollisionNodes.
 */
72
static inline CollideMask CollisionNode::get_default_collide_mask(void);

322 14 get_class_type 0 4 533 29 CollisionNode::get_class_type 0 1 60 0
54
static TypeHandle CollisionNode::get_class_type(void);

323 18 CollisionTraverser 0 4 540 38 CollisionTraverser::CollisionTraverser 0 2 61 62 10
/**
 *
 */
168
explicit CollisionTraverser::CollisionTraverser(std::string const &name = "ctrav");
inline CollisionTraverser::CollisionTraverser(CollisionTraverser const &) = default;

324 19 ~CollisionTraverser 0 4 540 39 CollisionTraverser::~CollisionTraverser 0 0 10
/**
 *
 */
46
CollisionTraverser::~CollisionTraverser(void);

325 26 set_respect_prev_transform 0 4 540 46 CollisionTraverser::set_respect_prev_transform 0 1 63 370
/**
 * Sets the flag that indicates whether the prev_transform stored on a node
 * (as updated via set_fluid_pos(), etc.) is respected to calculate
 * collisions.  If this is true, certain types of collision tests will be
 * enhanced by the information about objects in motion.  If this is false,
 * objects are always considered to be static.  The default is false.
 */
70
inline void CollisionTraverser::set_respect_prev_transform(bool flag);

326 26 get_respect_prev_transform 0 4 540 46 CollisionTraverser::get_respect_prev_transform 0 1 64 162
/**
 * Returns the flag that indicates whether the prev_transform stored on a node
 * is respected to calculate collisions.  See set_respect_prev_transform().
 */
71
inline bool CollisionTraverser::get_respect_prev_transform(void) const;

327 12 add_collider 0 4 540 32 CollisionTraverser::add_collider 0 1 65 437
/**
 * Adds a new CollisionNode, representing an object that will be tested for
 * collisions into other objects, along with the handler that will serve each
 * detected collision.  Each CollisionNode may be served by only one handler
 * at a time, but a given handler may serve many CollisionNodes.
 *
 * The handler that serves a particular node may be changed from time to time
 * by calling add_collider() again on the same node.
 */
91
void CollisionTraverser::add_collider(NodePath const &collider, CollisionHandler *handler);

328 15 remove_collider 0 4 540 35 CollisionTraverser::remove_collider 0 1 66 263
/**
 * Removes the collider (and its associated handler) from the set of
 * CollisionNodes that will be tested each frame for collisions into other
 * objects.  Returns true if the definition was found and removed, false if it
 * wasn't present to begin with.
 */
67
bool CollisionTraverser::remove_collider(NodePath const &collider);

329 12 has_collider 0 4 540 32 CollisionTraverser::has_collider 0 1 67 145
/**
 * Returns true if the indicated node is current in the set of nodes that will
 * be tested each frame for collisions into other objects.
 */
70
bool CollisionTraverser::has_collider(NodePath const &collider) const;

330 17 get_num_colliders 0 4 540 37 CollisionTraverser::get_num_colliders 0 1 68 108
/**
 * Returns the number of CollisionNodes that have been added to the traverser
 * via add_collider().
 */
54
int CollisionTraverser::get_num_colliders(void) const;

331 12 get_collider 0 4 540 32 CollisionTraverser::get_collider 0 1 69 100
/**
 * Returns the nth CollisionNode that has been added to the traverser via
 * add_collider().
 */
55
NodePath CollisionTraverser::get_collider(int n) const;

332 11 get_handler 0 4 540 31 CollisionTraverser::get_handler 0 1 70 169
/**
 * Returns the handler that is currently assigned to serve the indicated
 * collision node, or NULL if the node is not on the traverser's set of active
 * nodes.
 */
82
CollisionHandler *CollisionTraverser::get_handler(NodePath const &collider) const;

333 15 clear_colliders 0 4 540 35 CollisionTraverser::clear_colliders 0 1 71 90
/**
 * Completely empties the set of collision nodes and their associated
 * handlers.
 */
47
void CollisionTraverser::clear_colliders(void);

334 8 traverse 0 4 540 28 CollisionTraverser::traverse 0 1 72 10
/**
 *
 */
56
void CollisionTraverser::traverse(NodePath const &root);

335 12 set_recorder 0 4 540 32 CollisionTraverser::set_recorder 0 1 73 777
/**
 * Uses the indicated CollisionRecorder object to start recording the
 * intersection tests made by each subsequent call to traverse() on this
 * object.  A particular CollisionRecorder object can only record one
 * traverser at a time; if this object has already been assigned to another
 * traverser, that assignment is broken.
 *
 * This is intended to be used in a debugging mode to try to determine what
 * work is being performed by the collision traversal.  Usually, attaching a
 * recorder will impose significant runtime overhead.
 *
 * This does not transfer ownership of the CollisionRecorder pointer;
 * maintenance of that remains the caller's responsibility.  If the
 * CollisionRecorder is destructed, it will cleanly remove itself from the
 * traverser.
 */
67
void CollisionTraverser::set_recorder(CollisionRecorder *recorder);

336 12 has_recorder 0 4 540 32 CollisionTraverser::has_recorder 0 1 74 120
/**
 * Returns true if the CollisionTraverser has a CollisionRecorder object
 * currently assigned, false otherwise.
 */
57
inline bool CollisionTraverser::has_recorder(void) const;

337 12 get_recorder 0 4 540 32 CollisionTraverser::get_recorder 0 1 75 99
/**
 * Returns the CollisionRecorder currently assigned, or NULL if no recorder is
 * assigned.
 */
71
inline CollisionRecorder *CollisionTraverser::get_recorder(void) const;

338 14 clear_recorder 0 4 540 34 CollisionTraverser::clear_recorder 0 1 76 107
/**
 * Removes the CollisionRecorder from the traverser and restores normal low-
 * overhead operation.
 */
53
inline void CollisionTraverser::clear_recorder(void);

339 6 output 0 4 544 25 CollisionRecorder::output 0 1 82 10
/**
 *
 */
56
void CollisionRecorder::output(std::ostream &out) const;

340 14 get_class_type 0 4 544 33 CollisionRecorder::get_class_type 0 1 83 0
58
static TypeHandle CollisionRecorder::get_class_type(void);

341 15 show_collisions 0 4 540 35 CollisionTraverser::show_collisions 0 1 77 300
/**
 * This is a high-level function to create a CollisionVisualizer object to
 * render the collision tests performed by this traverser.  The supplied root
 * should be any node in the scene graph; typically, the top node (e.g.
 * render).  The CollisionVisualizer will be attached to this node.
 */
69
PandaNode *CollisionTraverser::show_collisions(NodePath const &root);

342 15 hide_collisions 0 4 540 35 CollisionTraverser::hide_collisions 0 1 78 69
/**
 * Undoes the effect of a previous call to show_collisions().
 */
47
void CollisionTraverser::hide_collisions(void);

343 6 output 0 4 540 26 CollisionTraverser::output 0 1 79 10
/**
 *
 */
57
void CollisionTraverser::output(std::ostream &out) const;

344 5 write 0 4 540 25 CollisionTraverser::write 0 1 80 10
/**
 *
 */
74
void CollisionTraverser::write(std::ostream &out, int indent_level) const;

345 14 get_class_type 0 4 540 34 CollisionTraverser::get_class_type 0 1 81 0
59
static TypeHandle CollisionTraverser::get_class_type(void);

346 8 get_from 0 4 546 24 CollisionEntry::get_from 0 1 84 104
/**
 * Returns the CollisionSolid pointer for the particular solid that triggered
 * this collision.
 */
66
inline CollisionSolid const *CollisionEntry::get_from(void) const;

347 8 has_into 0 4 546 24 CollisionEntry::has_into 0 1 85 288
/**
 * Returns true if the "into" solid is, in fact, a CollisionSolid, and its
 * pointer is known (in which case get_into() may be called to retrieve it).
 * If this returns false, the collision was detected into a GeomNode, and
 * there is no CollisionSolid pointer to be retrieved.
 */
49
inline bool CollisionEntry::has_into(void) const;

348 8 get_into 0 4 546 24 CollisionEntry::get_into 0 1 86 243
/**
 * Returns the CollisionSolid pointer for the particular solid was collided
 * into.  This pointer might be NULL if the collision was into a piece of
 * visible geometry, instead of a normal CollisionSolid collision; see
 * has_into().
 */
66
inline CollisionSolid const *CollisionEntry::get_into(void) const;

349 13 get_from_node 0 4 546 29 CollisionEntry::get_from_node 0 1 87 182
/**
 * Returns the node that contains the CollisionSolid that triggered this
 * collision.  This will be a node that has been added to a CollisionTraverser
 * via add_collider().
 */
64
inline CollisionNode *CollisionEntry::get_from_node(void) const;

350 13 get_into_node 0 4 546 29 CollisionEntry::get_into_node 0 1 88 254
/**
 * Returns the node that contains the CollisionSolid that was collided into.
 * This returns a PandaNode pointer instead of something more specific,
 * because it might be either a CollisionNode or a GeomNode.
 *
 * Also see get_into_node_path().
 */
60
inline PandaNode *CollisionEntry::get_into_node(void) const;

351 18 get_from_node_path 0 4 546 34 CollisionEntry::get_from_node_path 0 1 89 224
/**
 * Returns the NodePath that represents the CollisionNode that contains the
 * CollisionSolid that triggered this collision.  This will be a NodePath that
 * has been added to a CollisionTraverser via add_collider().
 */
63
inline NodePath CollisionEntry::get_from_node_path(void) const;

352 18 get_into_node_path 0 4 546 34 CollisionEntry::get_into_node_path 0 1 90 338
/**
 * Returns the NodePath that represents the specific CollisionNode or GeomNode
 * instance that was collided into.  This is the same node returned by
 * get_into_node(), represented as a NodePath; however, it may be more useful
 * because the NodePath can resolve the particular instance of the node, if
 * there is more than one.
 */
63
inline NodePath CollisionEntry::get_into_node_path(void) const;

353 5 set_t 0 4 546 21 CollisionEntry::set_t 0 1 91 82
/**
 * Sets a time value for this collision relative to other CollisionEntries
 */
49
inline void CollisionEntry::set_t(PN_stdfloat t);

354 5 get_t 0 4 546 21 CollisionEntry::get_t 0 1 92 83
/**
 * returns time value for this collision relative to other CollisionEntries
 */
53
inline PN_stdfloat CollisionEntry::get_t(void) const;

355 8 collided 0 4 546 24 CollisionEntry::collided 0 1 93 188
/**
 * returns true if this represents an actual collision as opposed to a
 * potential collision, needed for iterative collision resolution where path
 * of collider changes mid-frame
 */
49
inline bool CollisionEntry::collided(void) const;

356 14 reset_collided 0 4 546 30 CollisionEntry::reset_collided 0 1 94 45
/**
 * prepare for another collision test
 */
49
inline void CollisionEntry::reset_collided(void);

357 26 get_respect_prev_transform 0 4 546 42 CollisionEntry::get_respect_prev_transform 0 1 95 203
/**
 * Returns true if the collision was detected by a CollisionTraverser whose
 * respect_prev_transform flag was set true, meaning we should consider motion
 * significant in evaluating collisions.
 */
67
inline bool CollisionEntry::get_respect_prev_transform(void) const;

358 17 set_surface_point 0 4 546 33 CollisionEntry::set_surface_point 0 1 96 178
/**
 * Stores the point, on the surface of the "into" object, at which a collision
 * is detected.
 *
 * This point is specified in the coordinate space of the "into" object.
 */
68
inline void CollisionEntry::set_surface_point(LPoint3 const &point);

359 18 set_surface_normal 0 4 546 34 CollisionEntry::set_surface_normal 0 1 97 171
/**
 * Stores the surface normal of the "into" object at the point of the
 * intersection.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */
71
inline void CollisionEntry::set_surface_normal(LVector3 const &normal);

360 18 set_interior_point 0 4 546 34 CollisionEntry::set_interior_point 0 1 98 352
/**
 * Stores the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).
 *
 * This point is specified in the coordinate space of the "into" object.
 */
69
inline void CollisionEntry::set_interior_point(LPoint3 const &point);

361 17 has_surface_point 0 4 546 33 CollisionEntry::has_surface_point 0 1 99 174
/**
 * Returns true if the surface point has been specified, false otherwise.  See
 * get_surface_point().  Some types of collisions may not compute the surface
 * point.
 */
58
inline bool CollisionEntry::has_surface_point(void) const;

362 18 has_surface_normal 0 4 546 34 CollisionEntry::has_surface_normal 0 1 100 176
/**
 * Returns true if the surface normal has been specified, false otherwise.
 * See get_surface_normal().  Some types of collisions may not compute the
 * surface normal.
 */
59
inline bool CollisionEntry::has_surface_normal(void) const;

363 18 has_interior_point 0 4 546 34 CollisionEntry::has_interior_point 0 1 101 176
/**
 * Returns true if the interior point has been specified, false otherwise.
 * See get_interior_point().  Some types of collisions may not compute the
 * interior point.
 */
59
inline bool CollisionEntry::has_interior_point(void) const;

364 15 set_contact_pos 0 4 546 31 CollisionEntry::set_contact_pos 0 1 102 190
/**
 * Stores the position of the "from" object at the instant at which the
 * collision is first detected.
 *
 * This position is specified in the coordinate space of the "into" object.
 */
64
inline void CollisionEntry::set_contact_pos(LPoint3 const &pos);

365 18 set_contact_normal 0 4 546 34 CollisionEntry::set_contact_normal 0 1 103 154
/**
 * Stores the surface normal of the "into" object at the contact pos.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */
71
inline void CollisionEntry::set_contact_normal(LVector3 const &normal);

366 15 has_contact_pos 0 4 546 31 CollisionEntry::has_contact_pos 0 1 104 172
/**
 * Returns true if the contact position has been specified, false otherwise.
 * See get_contact_pos().  Some types of collisions may not compute the
 * contact pos.
 */
56
inline bool CollisionEntry::has_contact_pos(void) const;

367 18 has_contact_normal 0 4 546 34 CollisionEntry::has_contact_normal 0 1 105 176
/**
 * Returns true if the contact normal has been specified, false otherwise.
 * See get_contact_normal().  Some types of collisions may not compute the
 * contact normal.
 */
59
inline bool CollisionEntry::has_contact_normal(void) const;

368 17 get_surface_point 0 4 546 33 CollisionEntry::get_surface_point 0 1 106 330
/**
 * Returns the point, on the surface of the "into" object, at which a
 * collision is detected.  This can be thought of as the first point of
 * intersection.  However the contact point is the actual first point of
 * intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */
71
LPoint3 CollisionEntry::get_surface_point(NodePath const &space) const;

369 18 get_surface_normal 0 4 546 34 CollisionEntry::get_surface_normal 0 1 107 200
/**
 * Returns the surface normal of the "into" object at the point at which a
 * collision is detected.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */
73
LVector3 CollisionEntry::get_surface_normal(NodePath const &space) const;

370 18 get_interior_point 0 4 546 34 CollisionEntry::get_interior_point 0 1 108 431
/**
 * Returns the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).  It can be thought of as the
 * deepest point of intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */
72
LPoint3 CollisionEntry::get_interior_point(NodePath const &space) const;

371 7 get_all 0 4 546 23 CollisionEntry::get_all 0 1 109 244
/**
 * Simultaneously transforms the surface point, surface normal, and interior
 * point of the collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */
133
bool CollisionEntry::get_all(NodePath const &space, LPoint3 &surface_point, LVector3 &surface_normal, LPoint3 &interior_point) const;

372 15 get_contact_pos 0 4 546 31 CollisionEntry::get_contact_pos 0 1 110 200
/**
 * Returns the position of the "from" object at the instant that a collision
 * is first detected.
 *
 * The position will be converted into whichever coordinate space the caller
 * specifies.
 */
69
LPoint3 CollisionEntry::get_contact_pos(NodePath const &space) const;

373 18 get_contact_normal 0 4 546 34 CollisionEntry::get_contact_normal 0 1 111 175
/**
 * Returns the surface normal of the "into" object at the contact position.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */
73
LVector3 CollisionEntry::get_contact_normal(NodePath const &space) const;

374 20 get_all_contact_info 0 4 546 36 CollisionEntry::get_all_contact_info 0 1 112 230
/**
 * Simultaneously transforms the contact position and contact normal of the
 * collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */
119
bool CollisionEntry::get_all_contact_info(NodePath const &space, LPoint3 &contact_pos, LVector3 &contact_normal) const;

375 6 output 0 4 546 22 CollisionEntry::output 0 1 113 10
/**
 *
 */
53
void CollisionEntry::output(std::ostream &out) const;

376 5 write 0 4 546 21 CollisionEntry::write 0 1 114 10
/**
 *
 */
74
void CollisionEntry::write(std::ostream &out, int indent_level = 0) const;

377 14 get_class_type 0 4 546 30 CollisionEntry::get_class_type 0 1 115 0
55
static TypeHandle CollisionEntry::get_class_type(void);

378 15 ~CollisionEntry 0 4 546 31 CollisionEntry::~CollisionEntry 0 0 0
38
CollisionEntry::~CollisionEntry(void);

379 14 CollisionPlane 0 4 552 30 CollisionPlane::CollisionPlane 0 2 116 117 168
/**
 * This is only for the convenience of CollisionPolygon.  Normally, you should
 * not attempt to create an uninitialized CollisionPlane.
 */

/**
 *
 */

/**
 *
 */
126
inline CollisionPlane::CollisionPlane(LPlane const &plane);
inline CollisionPlane::CollisionPlane(CollisionPlane const &copy);

380 10 get_normal 0 4 552 26 CollisionPlane::get_normal 0 1 118 10
/**
 *
 */
55
inline LVector3 CollisionPlane::get_normal(void) const;

381 13 dist_to_plane 0 4 552 29 CollisionPlane::dist_to_plane 0 1 119 10
/**
 *
 */
77
inline PN_stdfloat CollisionPlane::dist_to_plane(LPoint3 const &point) const;

382 9 set_plane 0 4 552 25 CollisionPlane::set_plane 0 1 120 10
/**
 *
 */
59
inline void CollisionPlane::set_plane(LPlane const &plane);

383 9 get_plane 0 4 552 25 CollisionPlane::get_plane 0 1 121 10
/**
 *
 */
59
inline LPlane const &CollisionPlane::get_plane(void) const;

384 4 flip 0 4 552 20 CollisionPlane::flip 0 1 122 57
/**
 * Convenience method to flip the plane in-place.
 */
39
inline void CollisionPlane::flip(void);

385 14 get_class_type 0 4 552 30 CollisionPlane::get_class_type 0 1 123 0
55
static TypeHandle CollisionPlane::get_class_type(void);

386 15 ~CollisionPlane 0 4 552 31 CollisionPlane::~CollisionPlane 0 0 0
38
CollisionPlane::~CollisionPlane(void);

387 18 CollisionFloorMesh 0 4 556 38 CollisionFloorMesh::CollisionFloorMesh 0 1 124 156
/**
 * This is only for the convenience of CollisionPolygon.  Normally, you should
 * not attempt to create an uninitialized CollisionPlane.
 */

/**
 *
 */
52
inline CollisionFloorMesh::CollisionFloorMesh(void);

388 10 add_vertex 0 4 556 30 CollisionFloorMesh::add_vertex 0 1 125 47
/**
 * store away a vertex to index against
 */
64
inline void CollisionFloorMesh::add_vertex(LPoint3 const &vert);

389 12 add_triangle 0 4 556 32 CollisionFloorMesh::add_triangle 0 1 126 42
/**
 * store a triangle for processing
 */
101
void CollisionFloorMesh::add_triangle(unsigned int pointA, unsigned int pointB, unsigned int pointC);

390 16 get_num_vertices 0 4 556 36 CollisionFloorMesh::get_num_vertices 0 1 127 0
69
inline unsigned int CollisionFloorMesh::get_num_vertices(void) const;

391 10 get_vertex 0 4 556 30 CollisionFloorMesh::get_vertex 0 1 128 0
79
inline LPoint3 const &CollisionFloorMesh::get_vertex(unsigned int index) const;

392 17 get_num_triangles 0 4 556 37 CollisionFloorMesh::get_num_triangles 0 1 129 0
70
inline unsigned int CollisionFloorMesh::get_num_triangles(void) const;

393 12 get_triangle 0 4 556 32 CollisionFloorMesh::get_triangle 0 1 130 0
75
inline LPoint3i CollisionFloorMesh::get_triangle(unsigned int index) const;

394 14 get_class_type 0 4 556 34 CollisionFloorMesh::get_class_type 0 1 131 0
59
static TypeHandle CollisionFloorMesh::get_class_type(void);

395 19 ~CollisionFloorMesh 0 4 556 39 CollisionFloorMesh::~CollisionFloorMesh 0 0 0
46
CollisionFloorMesh::~CollisionFloorMesh(void);

396 16 CollisionPolygon 0 4 558 34 CollisionPolygon::CollisionPolygon 0 2 132 133 127
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid polygon.  Only used when reading from a bam file.
 */

/**
 *
 */
225
inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c);
inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c, LVecBase3 const &d);

397 14 get_num_points 0 4 558 32 CollisionPolygon::get_num_points 0 1 134 66
/**
 * Returns the number of vertices of the CollisionPolygon.
 */
64
inline std::size_t CollisionPolygon::get_num_points(void) const;

398 9 get_point 0 4 558 27 CollisionPolygon::get_point 0 1 135 82
/**
 * Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.
 */
64
inline LPoint3 CollisionPolygon::get_point(std::size_t n) const;

399 13 verify_points 0 4 558 31 CollisionPolygon::verify_points 0 2 136 137 676
/**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */

/**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */

/**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 *
 * This does not check that the polygon defined is convex; that check is made
 * later, once we have projected the points to 2-d space where the decision is
 * easier.
 */
222
static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d);
static bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c);

400 8 is_valid 0 4 558 26 CollisionPolygon::is_valid 0 1 138 122
/**
 * Returns true if the CollisionPolygon is valid (that is, it has at least
 * three vertices), or false otherwise.
 */
44
bool CollisionPolygon::is_valid(void) const;

401 10 is_concave 0 4 558 28 CollisionPolygon::is_concave 0 1 139 106
/**
 * Returns true if the CollisionPolygon appears to be concave, or false if it
 * is safely convex.
 */
46
bool CollisionPolygon::is_concave(void) const;

402 14 get_class_type 0 4 558 32 CollisionPolygon::get_class_type 0 1 140 0
57
static TypeHandle CollisionPolygon::get_class_type(void);

403 17 ~CollisionPolygon 0 4 558 35 CollisionPolygon::~CollisionPolygon 0 0 0
42
CollisionPolygon::~CollisionPolygon(void);

404 21 CollisionHandlerEvent 0 4 559 44 CollisionHandlerEvent::CollisionHandlerEvent 0 2 141 142 168
/**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */
145
CollisionHandlerEvent::CollisionHandlerEvent(void);
inline CollisionHandlerEvent::CollisionHandlerEvent(CollisionHandlerEvent const &) = default;

405 17 clear_in_patterns 0 4 559 40 CollisionHandlerEvent::clear_in_patterns 0 1 143 80
/**
 * Removes all of the previously-added in patterns.  See add_in_pattern.
 */
59
inline void CollisionHandlerEvent::clear_in_patterns(void);

406 14 add_in_pattern 0 4 559 37 CollisionHandlerEvent::add_in_pattern 0 1 144 1586
/**
 * Adds a pattern string to the list of events that will be generated in
 * response to a collision.  The pattern string describes how the event name
 * will be composed.  It is a string that may contain any of the following:
 *
 * %fn  - the name of the "from" object's node %in  - the name of the "into"
 * object's node %fs  - 't' if "from" is tangible, 'i' if intangible %is  -
 * 't' if "into" is tangible, 'i' if intangible %ig  - 'c' if the collision is
 * into a CollisionNode, 'g' if it is a geom.
 *
 * %(tag)fh - generate event only if "from" node has the indicated net tag.
 * %(tag)fx - generate event only if "from" node does not have the indicated
 * net tag.  %(tag)ih - generate event only if "into" node has the indicated
 * net tag.  %(tag)ix - generate event only if "into" node does not have the
 * indicated net tag.  %(tag)ft - the indicated net tag value of the "from"
 * node.  %(tag)it - the indicated net tag value of the "into" node.
 *
 * Parentheses in the above are literal and should be included in the actual
 * pattern.
 *
 * The event name will be based on the in_pattern string specified here, with
 * all occurrences of the above strings replaced with the corresponding
 * values.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */
81
inline void CollisionHandlerEvent::add_in_pattern(std::string const &in_pattern);

407 14 set_in_pattern 0 4 559 37 CollisionHandlerEvent::set_in_pattern 0 1 145 189
/**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_in_pattern() instead.
 */
81
inline void CollisionHandlerEvent::set_in_pattern(std::string const &in_pattern);

408 19 get_num_in_patterns 0 4 559 42 CollisionHandlerEvent::get_num_in_patterns 0 1 146 73
/**
 * Returns the number of in pattern strings that have been added.
 */
66
inline int CollisionHandlerEvent::get_num_in_patterns(void) const;

409 14 get_in_pattern 0 4 559 37 CollisionHandlerEvent::get_in_pattern 0 1 147 145
/**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_in_pattern().
 */
70
inline std::string CollisionHandlerEvent::get_in_pattern(int n) const;

410 20 clear_again_patterns 0 4 559 43 CollisionHandlerEvent::clear_again_patterns 0 1 148 83
/**
 * Removes all of the previously-added in patterns.  See add_again_pattern.
 */
62
inline void CollisionHandlerEvent::clear_again_patterns(void);

411 17 add_again_pattern 0 4 559 40 CollisionHandlerEvent::add_again_pattern 0 1 149 649
/**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *still* detected.  This
 * event is thrown each consecutive time a collision between two particular
 * nodes is detected, starting with the second time.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */
87
inline void CollisionHandlerEvent::add_again_pattern(std::string const &again_pattern);

412 17 set_again_pattern 0 4 559 40 CollisionHandlerEvent::set_again_pattern 0 1 150 192
/**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_again_pattern() instead.
 */
87
inline void CollisionHandlerEvent::set_again_pattern(std::string const &again_pattern);

413 22 get_num_again_patterns 0 4 559 45 CollisionHandlerEvent::get_num_again_patterns 0 1 151 73
/**
 * Returns the number of in pattern strings that have been added.
 */
69
inline int CollisionHandlerEvent::get_num_again_patterns(void) const;

414 17 get_again_pattern 0 4 559 40 CollisionHandlerEvent::get_again_pattern 0 1 152 148
/**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_again_pattern().
 */
73
inline std::string CollisionHandlerEvent::get_again_pattern(int n) const;

415 18 clear_out_patterns 0 4 559 41 CollisionHandlerEvent::clear_out_patterns 0 1 153 81
/**
 * Removes all of the previously-added in patterns.  See add_out_pattern.
 */
60
inline void CollisionHandlerEvent::clear_out_patterns(void);

416 15 add_out_pattern 0 4 559 38 CollisionHandlerEvent::add_out_pattern 0 1 154 518
/**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *no longer* detected.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */
83
inline void CollisionHandlerEvent::add_out_pattern(std::string const &out_pattern);

417 15 set_out_pattern 0 4 559 38 CollisionHandlerEvent::set_out_pattern 0 1 155 190
/**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_out_pattern() instead.
 */
83
inline void CollisionHandlerEvent::set_out_pattern(std::string const &out_pattern);

418 20 get_num_out_patterns 0 4 559 43 CollisionHandlerEvent::get_num_out_patterns 0 1 156 73
/**
 * Returns the number of in pattern strings that have been added.
 */
67
inline int CollisionHandlerEvent::get_num_out_patterns(void) const;

419 15 get_out_pattern 0 4 559 38 CollisionHandlerEvent::get_out_pattern 0 1 157 146
/**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_out_pattern().
 */
71
inline std::string CollisionHandlerEvent::get_out_pattern(int n) const;

420 5 clear 0 4 559 28 CollisionHandlerEvent::clear 0 1 158 541
/**
 * Empties the list of elements that all colliders are known to be colliding
 * with.  No "out" events will be thrown; if the same collision is detected
 * next frame, a new "in" event will be thrown for each collision.
 *
 * This can be called each frame to defeat the persistent "in" event
 * mechanism, which prevents the same "in" event from being thrown repeatedly.
 * However, also see add_again_pattern(), which can be used to set the event
 * that is thrown when a collision is detected for two or more consecutive
 * frames.
 */
40
void CollisionHandlerEvent::clear(void);

421 5 flush 0 4 559 28 CollisionHandlerEvent::flush 0 1 159 58
/**
 * Same as clear() except "out" events are thrown.
 */
40
void CollisionHandlerEvent::flush(void);

422 14 get_class_type 0 4 559 37 CollisionHandlerEvent::get_class_type 0 1 160 0
62
static TypeHandle CollisionHandlerEvent::get_class_type(void);

423 22 ~CollisionHandlerEvent 0 4 559 45 CollisionHandlerEvent::~CollisionHandlerEvent 0 0 0
52
CollisionHandlerEvent::~CollisionHandlerEvent(void);

424 12 add_collider 0 4 562 38 CollisionHandlerPhysical::add_collider 0 2 161 162 556
/**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 */

/**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 *
 * The indicated DriveInterface will also be updated with the target's new
 * transform each frame.  This method should be used when the target is
 * directly controlled by a DriveInterface.
 */
222
void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target);
void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target, DriveInterface *drive_interface);

425 15 remove_collider 0 4 562 41 CollisionHandlerPhysical::remove_collider 0 1 163 92
/**
 * Removes the collider from the list of colliders that this handler knows
 * about.
 */
73
bool CollisionHandlerPhysical::remove_collider(NodePath const &collider);

426 12 has_collider 0 4 562 38 CollisionHandlerPhysical::has_collider 0 1 164 94
/**
 * Returns true if the handler knows about the indicated collider, false
 * otherwise.
 */
76
bool CollisionHandlerPhysical::has_collider(NodePath const &collider) const;

427 15 clear_colliders 0 4 562 41 CollisionHandlerPhysical::clear_colliders 0 1 165 77
/**
 * Completely empties the list of colliders this handler knows about.
 */
53
void CollisionHandlerPhysical::clear_colliders(void);

428 10 set_center 0 4 562 36 CollisionHandlerPhysical::set_center 0 1 166 269
/**
 * Specifies an arbitrary NodePath that the handler is always considered to be
 * facing.  It does not detect collisions with surfaces that appear to be
 * facing away from this NodePath.  This works best when the collision
 * surfaces in question are polygons.
 */
73
inline void CollisionHandlerPhysical::set_center(NodePath const &center);

429 12 clear_center 0 4 562 38 CollisionHandlerPhysical::clear_center 0 1 167 64
/**
 * Clears the center NodePath specified with set_center.
 */
57
inline void CollisionHandlerPhysical::clear_center(void);

430 10 get_center 0 4 562 36 CollisionHandlerPhysical::get_center 0 1 168 114
/**
 * Returns the NodePath specified with set_center, or the empty NodePath if
 * nothing has been specified.
 */
72
inline NodePath const &CollisionHandlerPhysical::get_center(void) const;

431 10 has_center 0 4 562 36 CollisionHandlerPhysical::has_center 0 1 169 95
/**
 * Returns true if a NodePath has been specified with set_center(), false
 * otherwise.
 */
61
inline bool CollisionHandlerPhysical::has_center(void) const;

432 11 has_contact 0 4 562 37 CollisionHandlerPhysical::has_contact 0 1 170 255
/**
 * Did the handler make any contacts with anything on the last collision pass?
 * Depending on how your world is setup, this can be used to tell if the
 * handler is out of the world (i.e.  out of bounds). That is the original use
 * of this call.
 */
62
inline bool CollisionHandlerPhysical::has_contact(void) const;

433 14 get_class_type 0 4 562 40 CollisionHandlerPhysical::get_class_type 0 1 171 0
65
static TypeHandle CollisionHandlerPhysical::get_class_type(void);

434 21 CollisionHandlerFloor 0 4 564 44 CollisionHandlerFloor::CollisionHandlerFloor 0 1 172 10
/**
 *
 */
51
CollisionHandlerFloor::CollisionHandlerFloor(void);

435 10 set_offset 0 4 564 33 CollisionHandlerFloor::set_offset 0 1 173 166
/**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
66
inline void CollisionHandlerFloor::set_offset(PN_stdfloat offset);

436 10 get_offset 0 4 564 33 CollisionHandlerFloor::get_offset 0 1 174 169
/**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
65
inline PN_stdfloat CollisionHandlerFloor::get_offset(void) const;

437 9 set_reach 0 4 564 32 CollisionHandlerFloor::set_reach 0 1 175 82
/**
 * Sets the reach to add to (or subtract from) the highest collision point
 */
64
inline void CollisionHandlerFloor::set_reach(PN_stdfloat reach);

438 9 get_reach 0 4 564 32 CollisionHandlerFloor::get_reach 0 1 176 85
/**
 * Returns the reach to add to (or subtract from) the highest collision point
 */
64
inline PN_stdfloat CollisionHandlerFloor::get_reach(void) const;

439 16 set_max_velocity 0 4 564 39 CollisionHandlerFloor::set_max_velocity 0 1 177 199
/**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */
73
inline void CollisionHandlerFloor::set_max_velocity(PN_stdfloat max_vel);

440 16 get_max_velocity 0 4 564 39 CollisionHandlerFloor::get_max_velocity 0 1 178 160
/**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */
71
inline PN_stdfloat CollisionHandlerFloor::get_max_velocity(void) const;

441 14 get_class_type 0 4 564 37 CollisionHandlerFloor::get_class_type 0 1 179 0
62
static TypeHandle CollisionHandlerFloor::get_class_type(void);

442 22 CollisionHandlerPusher 0 4 565 46 CollisionHandlerPusher::CollisionHandlerPusher 0 1 180 10
/**
 *
 */
53
CollisionHandlerPusher::CollisionHandlerPusher(void);

443 14 set_horizontal 0 4 565 38 CollisionHandlerPusher::set_horizontal 0 1 181 10
/**
 *
 */
62
inline void CollisionHandlerPusher::set_horizontal(bool flag);

444 14 get_horizontal 0 4 565 38 CollisionHandlerPusher::get_horizontal 0 1 182 10
/**
 *
 */
63
inline bool CollisionHandlerPusher::get_horizontal(void) const;

445 14 get_class_type 0 4 565 38 CollisionHandlerPusher::get_class_type 0 1 183 0
63
static TypeHandle CollisionHandlerPusher::get_class_type(void);

446 27 CollisionHandlerFluidPusher 0 4 566 56 CollisionHandlerFluidPusher::CollisionHandlerFluidPusher 0 1 184 10
/**
 *
 */
63
CollisionHandlerFluidPusher::CollisionHandlerFluidPusher(void);

447 14 get_class_type 0 4 566 43 CollisionHandlerFluidPusher::get_class_type 0 1 185 0
68
static TypeHandle CollisionHandlerFluidPusher::get_class_type(void);

448 28 ~CollisionHandlerFluidPusher 0 4 566 57 CollisionHandlerFluidPusher::~CollisionHandlerFluidPusher 0 0 0
64
CollisionHandlerFluidPusher::~CollisionHandlerFluidPusher(void);

449 23 CollisionHandlerGravity 0 4 567 48 CollisionHandlerGravity::CollisionHandlerGravity 0 1 186 10
/**
 *
 */
55
CollisionHandlerGravity::CollisionHandlerGravity(void);

450 10 set_offset 0 4 567 35 CollisionHandlerGravity::set_offset 0 1 187 166
/**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
68
inline void CollisionHandlerGravity::set_offset(PN_stdfloat offset);

451 10 get_offset 0 4 567 35 CollisionHandlerGravity::get_offset 0 1 188 169
/**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */
67
inline PN_stdfloat CollisionHandlerGravity::get_offset(void) const;

452 9 set_reach 0 4 567 34 CollisionHandlerGravity::set_reach 0 1 189 82
/**
 * Sets the reach to add to (or subtract from) the highest collision point
 */
66
inline void CollisionHandlerGravity::set_reach(PN_stdfloat reach);

453 9 get_reach 0 4 567 34 CollisionHandlerGravity::get_reach 0 1 190 85
/**
 * Returns the reach to add to (or subtract from) the highest collision point
 */
66
inline PN_stdfloat CollisionHandlerGravity::get_reach(void) const;

454 19 get_airborne_height 0 4 567 44 CollisionHandlerGravity::get_airborne_height 0 1 191 238
/**
 * Return the height of the object from the ground.
 *
 * The object might not necessarily be at rest.  Use is_on_ground() if you
 * want to know whether the object is on the ground and at rest.
 *
 * See Also: is_in_outer_space()
 */
76
inline PN_stdfloat CollisionHandlerGravity::get_airborne_height(void) const;

455 12 is_on_ground 0 4 567 37 CollisionHandlerGravity::is_on_ground 0 1 192 33
/**
 * Is the object at rest?
 */
62
inline bool CollisionHandlerGravity::is_on_ground(void) const;

456 19 get_impact_velocity 0 4 567 44 CollisionHandlerGravity::get_impact_velocity 0 1 193 282
/**
 * How hard did the object hit the ground.  This value is set on impact with
 * the ground.  You may want to watch (poll) on is_on_groun() and when that is
 * true, call get_impact_velocity(). Normally I avoid polling, but we are
 * calling is_on_ground() frequently anyway.
 */
76
inline PN_stdfloat CollisionHandlerGravity::get_impact_velocity(void) const;

457 18 get_contact_normal 0 4 567 43 CollisionHandlerGravity::get_contact_normal 0 1 194 10
/**
 *
 */
79
inline LVector3 const &CollisionHandlerGravity::get_contact_normal(void) const;

458 12 add_velocity 0 4 567 37 CollisionHandlerGravity::add_velocity 0 1 195 184
/**
 * Adds the sepcified amount to the current velocity.  This is mostly here
 * allow this common operation to be faster for scripting, but it's also more
 * concise even in cpp.
 */
72
inline void CollisionHandlerGravity::add_velocity(PN_stdfloat velocity);

459 12 set_velocity 0 4 567 37 CollisionHandlerGravity::set_velocity 0 1 196 46
/**
 * Sets the current vertical velocity.
 */
72
inline void CollisionHandlerGravity::set_velocity(PN_stdfloat velocity);

460 12 get_velocity 0 4 567 37 CollisionHandlerGravity::get_velocity 0 1 197 354
/**
 * Gets the current vertical velocity.
 *
 * Generally, negative values mean the object is in free fall; while postive
 * values mean the object has vertical thrust.
 *
 * A zero value does not necessarily mean the object on the ground, it may
 * also be weightless and/or at the apex of its jump.
 *
 * See Also: is_on_ground() and get_gravity()
 */
69
inline PN_stdfloat CollisionHandlerGravity::get_velocity(void) const;

461 11 set_gravity 0 4 567 36 CollisionHandlerGravity::set_gravity 0 1 198 56
/**
 * Sets the linear gravity force (always plumb).
 */
70
inline void CollisionHandlerGravity::set_gravity(PN_stdfloat gravity);

462 11 get_gravity 0 4 567 36 CollisionHandlerGravity::get_gravity 0 1 199 56
/**
 * Gets the linear gravity force (always plumb).
 */
68
inline PN_stdfloat CollisionHandlerGravity::get_gravity(void) const;

463 16 set_max_velocity 0 4 567 41 CollisionHandlerGravity::set_max_velocity 0 1 200 199
/**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */
75
inline void CollisionHandlerGravity::set_max_velocity(PN_stdfloat max_vel);

464 16 get_max_velocity 0 4 567 41 CollisionHandlerGravity::get_max_velocity 0 1 201 160
/**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */
73
inline PN_stdfloat CollisionHandlerGravity::get_max_velocity(void) const;

465 15 set_legacy_mode 0 4 567 40 CollisionHandlerGravity::set_legacy_mode 0 1 202 229
/**
 * Enables old behavior required by Toontown (Sellbot Factory lava room is
 * good test case, lava and conveyor belt specifically). Behavior is to throw
 * enter/exit events only for floor that the toon is in contact with
 */
71
inline void CollisionHandlerGravity::set_legacy_mode(bool legacy_mode);

466 15 get_legacy_mode 0 4 567 40 CollisionHandlerGravity::get_legacy_mode 0 1 203 49
/**
 * returns true if legacy mode is enabled
 */
65
inline bool CollisionHandlerGravity::get_legacy_mode(void) const;

467 14 get_class_type 0 4 567 39 CollisionHandlerGravity::get_class_type 0 1 204 0
64
static TypeHandle CollisionHandlerGravity::get_class_type(void);

468 28 CollisionHandlerHighestEvent 0 4 569 58 CollisionHandlerHighestEvent::CollisionHandlerHighestEvent 0 2 205 206 168
/**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */
180
CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(void);
inline CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(CollisionHandlerHighestEvent const &) = default;

469 14 get_class_type 0 4 569 44 CollisionHandlerHighestEvent::get_class_type 0 1 207 0
69
static TypeHandle CollisionHandlerHighestEvent::get_class_type(void);

470 29 ~CollisionHandlerHighestEvent 0 4 569 59 CollisionHandlerHighestEvent::~CollisionHandlerHighestEvent 0 0 0
66
CollisionHandlerHighestEvent::~CollisionHandlerHighestEvent(void);

471 21 CollisionHandlerQueue 0 4 570 44 CollisionHandlerQueue::CollisionHandlerQueue 0 2 208 209 10
/**
 *
 */
145
CollisionHandlerQueue::CollisionHandlerQueue(void);
inline CollisionHandlerQueue::CollisionHandlerQueue(CollisionHandlerQueue const &) = default;

472 12 sort_entries 0 4 570 35 CollisionHandlerQueue::sort_entries 0 1 210 257
/**
 * Sorts all the detected collisions front-to-back by
 * from_intersection_point() so that those intersection points closest to the
 * collider's origin (e.g., the center of the CollisionSphere, or the point_a
 * of a CollisionSegment) appear first.
 */
47
void CollisionHandlerQueue::sort_entries(void);

473 13 clear_entries 0 4 570 36 CollisionHandlerQueue::clear_entries 0 1 211 50
/**
 * Removes all the entries from the queue.
 */
48
void CollisionHandlerQueue::clear_entries(void);

474 15 get_num_entries 0 4 570 38 CollisionHandlerQueue::get_num_entries 0 1 212 69
/**
 * Returns the number of CollisionEntries detected last pass.
 */
55
int CollisionHandlerQueue::get_num_entries(void) const;

475 9 get_entry 0 4 570 32 CollisionHandlerQueue::get_entry 0 1 213 61
/**
 * Returns the nth CollisionEntry detected last pass.
 */
62
CollisionEntry *CollisionHandlerQueue::get_entry(int n) const;

476 6 output 0 4 570 29 CollisionHandlerQueue::output 0 1 214 10
/**
 *
 */
60
void CollisionHandlerQueue::output(std::ostream &out) const;

477 5 write 0 4 570 28 CollisionHandlerQueue::write 0 1 215 10
/**
 *
 */
81
void CollisionHandlerQueue::write(std::ostream &out, int indent_level = 0) const;

478 14 get_class_type 0 4 570 37 CollisionHandlerQueue::get_class_type 0 1 216 0
62
static TypeHandle CollisionHandlerQueue::get_class_type(void);

479 22 ~CollisionHandlerQueue 0 4 570 45 CollisionHandlerQueue::~CollisionHandlerQueue 0 0 0
52
CollisionHandlerQueue::~CollisionHandlerQueue(void);

480 15 CollisionSphere 0 4 572 32 CollisionSphere::CollisionSphere 0 2 217 218 114
/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid sphere.  Only used when reading from a bam file.
 */

/**
 *
 */
210
inline explicit CollisionSphere::CollisionSphere(LPoint3 const &center, PN_stdfloat radius);
inline explicit CollisionSphere::CollisionSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius);

481 10 set_center 0 4 572 27 CollisionSphere::set_center 0 2 219 220 22
/**
 *
 */

/**
 *
 */
149
inline void CollisionSphere::set_center(LPoint3 const &center);
inline void CollisionSphere::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

482 10 get_center 0 4 572 27 CollisionSphere::get_center 0 1 221 10
/**
 *
 */
62
inline LPoint3 const &CollisionSphere::get_center(void) const;

483 10 set_radius 0 4 572 27 CollisionSphere::set_radius 0 1 222 10
/**
 *
 */
60
inline void CollisionSphere::set_radius(PN_stdfloat radius);

484 10 get_radius 0 4 572 27 CollisionSphere::get_radius 0 1 223 10
/**
 *
 */
59
inline PN_stdfloat CollisionSphere::get_radius(void) const;

485 14 get_class_type 0 4 572 31 CollisionSphere::get_class_type 0 1 224 0
56
static TypeHandle CollisionSphere::get_class_type(void);

486 16 ~CollisionSphere 0 4 572 33 CollisionSphere::~CollisionSphere 0 0 0
40
CollisionSphere::~CollisionSphere(void);

487 18 CollisionInvSphere 0 4 573 38 CollisionInvSphere::CollisionInvSphere 0 2 225 226 114
/**
 *
 */

/**
 *
 */

/**
 * Creates an invalid sphere.  Only used when reading from a bam file.
 */

/**
 *
 */
222
inline explicit CollisionInvSphere::CollisionInvSphere(LPoint3 const &center, PN_stdfloat radius);
inline explicit CollisionInvSphere::CollisionInvSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius);

488 14 get_class_type 0 4 573 34 CollisionInvSphere::get_class_type 0 1 227 0
59
static TypeHandle CollisionInvSphere::get_class_type(void);

489 19 ~CollisionInvSphere 0 4 573 39 CollisionInvSphere::~CollisionInvSphere 0 0 0
46
CollisionInvSphere::~CollisionInvSphere(void);

490 12 CollisionRay 0 4 574 26 CollisionRay::CollisionRay 0 3 228 229 230 219
/**
 * Creates an invalid ray.  This isn't terribly useful; it's expected that the
 * user will subsequently adjust the ray via set_origin()/set_direction() or
 * set_from_lens().
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
274
inline CollisionRay::CollisionRay(void);
inline explicit CollisionRay::CollisionRay(LPoint3 const &origin, LVector3 const &direction);
inline explicit CollisionRay::CollisionRay(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz);

491 10 set_origin 0 4 574 24 CollisionRay::set_origin 0 2 231 232 22
/**
 *
 */

/**
 *
 */
143
inline void CollisionRay::set_origin(LPoint3 const &origin);
inline void CollisionRay::set_origin(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

492 10 get_origin 0 4 574 24 CollisionRay::get_origin 0 1 233 10
/**
 *
 */
59
inline LPoint3 const &CollisionRay::get_origin(void) const;

493 13 set_direction 0 4 574 27 CollisionRay::set_direction 0 2 234 235 22
/**
 *
 */

/**
 *
 */
153
inline void CollisionRay::set_direction(LVector3 const &direction);
inline void CollisionRay::set_direction(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

494 13 get_direction 0 4 574 27 CollisionRay::get_direction 0 1 236 10
/**
 *
 */
63
inline LVector3 const &CollisionRay::get_direction(void) const;

495 13 set_from_lens 0 4 574 27 CollisionRay::set_from_lens 0 2 237 238 591
/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 */

/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */
164
bool CollisionRay::set_from_lens(LensNode *camera, LPoint2 const &point);
inline bool CollisionRay::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py);

496 14 get_class_type 0 4 574 28 CollisionRay::get_class_type 0 1 239 0
53
static TypeHandle CollisionRay::get_class_type(void);

497 13 ~CollisionRay 0 4 574 27 CollisionRay::~CollisionRay 0 0 0
34
CollisionRay::~CollisionRay(void);

498 13 CollisionLine 0 4 575 28 CollisionLine::CollisionLine 0 3 240 241 242 221
/**
 * Creates an invalid line.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the line via set_origin()/set_direction()
 * or set_from_lens().
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
280
inline CollisionLine::CollisionLine(void);
inline explicit CollisionLine::CollisionLine(LPoint3 const &origin, LVector3 const &direction);
inline explicit CollisionLine::CollisionLine(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz);

499 14 get_class_type 0 4 575 29 CollisionLine::get_class_type 0 1 243 0
54
static TypeHandle CollisionLine::get_class_type(void);

500 14 ~CollisionLine 0 4 575 29 CollisionLine::~CollisionLine 0 0 0
36
CollisionLine::~CollisionLine(void);

501 17 CollisionParabola 0 4 576 36 CollisionParabola::CollisionParabola 0 2 244 245 163
/**
 * Creates an invalid parabola.
 */

/**
 * Creates a parabola with the endpoints between t1 and t2 in the parametric
 * space of the parabola.
 */

/**
 *
 */
163
inline CollisionParabola::CollisionParabola(void);
inline explicit CollisionParabola::CollisionParabola(LParabola const &parabola, PN_stdfloat t1, PN_stdfloat t2);

502 12 set_parabola 0 4 576 31 CollisionParabola::set_parabola 0 1 246 57
/**
 * Replaces the parabola specified by this solid.
 */
71
inline void CollisionParabola::set_parabola(LParabola const &parabola);

503 12 get_parabola 0 4 576 31 CollisionParabola::get_parabola 0 1 247 56
/**
 * Returns the parabola specified by this solid.
 */
68
inline LParabola const &CollisionParabola::get_parabola(void) const;

504 6 set_t1 0 4 576 25 CollisionParabola::set_t1 0 1 248 54
/**
 * Changes the starting point on the parabola.
 */
54
inline void CollisionParabola::set_t1(PN_stdfloat t1);

505 6 get_t1 0 4 576 25 CollisionParabola::get_t1 0 1 249 54
/**
 * Returns the starting point on the parabola.
 */
57
inline PN_stdfloat CollisionParabola::get_t1(void) const;

506 6 set_t2 0 4 576 25 CollisionParabola::set_t2 0 1 250 52
/**
 * Changes the ending point on the parabola.
 */
54
inline void CollisionParabola::set_t2(PN_stdfloat t2);

507 6 get_t2 0 4 576 25 CollisionParabola::get_t2 0 1 251 52
/**
 * Returns the ending point on the parabola.
 */
57
inline PN_stdfloat CollisionParabola::get_t2(void) const;

508 14 get_class_type 0 4 576 33 CollisionParabola::get_class_type 0 1 252 0
58
static TypeHandle CollisionParabola::get_class_type(void);

509 18 ~CollisionParabola 0 4 576 37 CollisionParabola::~CollisionParabola 0 0 0
44
CollisionParabola::~CollisionParabola(void);

510 16 CollisionSegment 0 4 580 34 CollisionSegment::CollisionSegment 0 3 253 254 255 227
/**
 * Creates an invalid segment.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the segment via
 * set_origin()/set_direction() or set_from_lens().
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
285
inline CollisionSegment::CollisionSegment(void);
inline explicit CollisionSegment::CollisionSegment(LPoint3 const &a, LPoint3 const &db);
inline explicit CollisionSegment::CollisionSegment(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz);

511 11 set_point_a 0 4 580 29 CollisionSegment::set_point_a 0 2 256 257 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionSegment::set_point_a(LPoint3 const &a);
inline void CollisionSegment::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

512 11 get_point_a 0 4 580 29 CollisionSegment::get_point_a 0 1 258 10
/**
 *
 */
64
inline LPoint3 const &CollisionSegment::get_point_a(void) const;

513 11 set_point_b 0 4 580 29 CollisionSegment::set_point_b 0 2 259 260 22
/**
 *
 */

/**
 *
 */
148
inline void CollisionSegment::set_point_b(LPoint3 const &b);
inline void CollisionSegment::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);

514 11 get_point_b 0 4 580 29 CollisionSegment::get_point_b 0 1 261 10
/**
 *
 */
64
inline LPoint3 const &CollisionSegment::get_point_b(void) const;

515 13 set_from_lens 0 4 580 31 CollisionSegment::set_from_lens 0 2 262 263 609
/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 */

/**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */
172
bool CollisionSegment::set_from_lens(LensNode *camera, LPoint2 const &point);
inline bool CollisionSegment::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py);

516 14 get_class_type 0 4 580 32 CollisionSegment::get_class_type 0 1 264 0
57
static TypeHandle CollisionSegment::get_class_type(void);

517 17 ~CollisionSegment 0 4 580 35 CollisionSegment::~CollisionSegment 0 0 0
42
CollisionSegment::~CollisionSegment(void);

264
1 0 0 7 3 582 0 0 0 1 4 this 3 548  
2 0 0 4 7 584 0 0 295 /**
 * Sets the current state of the 'tangible' flag.  Set this true to make the
 * solid tangible, so that a CollisionHandlerPusher will not allow another
 * object to intersect it, or false to make it intangible, so that a
 * CollisionHandlerPusher will ignore it except to throw an event.
 */ 2 4 this 3 583  8 tangible 1 522  
3 0 0 6 8 522 0 0 266 /**
 * Returns whether the solid is considered 'tangible' or not.  An intangible
 * solid has no effect in a CollisionHandlerPusher (except to throw an event);
 * it's useful for defining 'trigger' planes and spheres, that cause an effect
 * when passed through.
 */ 1 4 this 3 548  
4 0 0 4 11 584 0 0 388 /**
 * Records a false normal for this CollisionSolid that will be reported by the
 * collision system with all collisions into it, instead of its actual normal.
 * This is useful as a workaround for the problem of an avatar wanting to
 * stand on a sloping ground; by storing a false normal, the ground appears to
 * be perfectly level, and the avatar does not tend to slide down it.
 */ 2 4 this 3 583  16 effective_normal 1 585  
5 0 0 4 12 584 0 0 71 /**
 * Removes the normal previously set by set_effective_normal().
 */ 1 4 this 3 583  
6 0 0 6 13 522 0 0 98 /**
 * Returns true if a special normal was set by set_effective_normal(), false
 * otherwise.
 */ 1 4 this 3 548  
7 0 0 6 14 585 0 0 145 /**
 * Returns the normal that was set by set_effective_normal().  It is an error
 * to call this unless has_effective_normal() returns true.
 */ 1 4 this 3 548  
8 0 0 4 15 584 0 0 296 /**
 * This is only meaningful for CollisionSolids that will be added to a
 * traverser as colliders.  It is normally true, but if set false, it means
 * that this particular solid does not care about the "effective" normal of
 * other solids it meets, but rather always uses the true normal.
 */ 2 4 this 3 583  24 respect_effective_normal 1 522  
9 0 0 6 16 522 0 0 46 /**
 * See set_respect_effective_normal().
 */ 1 4 this 3 548  
10 0 0 7 18 588 0 0 47 /**
 * Returns the solid's bounding volume.
 */ 1 4 this 3 548  
11 0 0 4 19 584 0 0 47 /**
 * Returns the solid's bounding volume.
 */ 2 4 this 3 583  15 bounding_volume 1 588  
12 0 0 4 22 584 0 0 10 /**
 *
 */ 2 4 this 3 548  3 out 1 589  
13 0 0 4 23 584 0 0 10 /**
 *
 */ 3 4 this 3 548  3 out 1 589  12 indent_level 1 539  
14 0 0 7 24 592 0 0 0 0 
15 0 0 7 26 594 292 0 59 /**
 * Create the Box by Specifying the Diagonal Points
 */ 2 3 min 1 593  3 max 1 593  
16 0 0 7 26 594 292 0 106 /**
 * Create the Box by giving a Center and distances of each of the sides of
 * box from the Center.
 */ 4 6 center 1 593  1 x 1 529  1 y 1 529  1 z 1 529  
17 0 0 6 27 539 0 0 68 /**
 * Returns 8: the number of vertices of a rectangular solid.
 */ 1 4 this 3 595  
18 0 0 7 28 582 0 0 67 /**
 * Returns the nth vertex of the Axis Aligned Bounding Box.
 */ 2 4 this 3 595  1 n 1 539  
19 0 0 7 29 582 0 0 45 /**
 * Returns the nth vertex of the OBB.
 */ 2 4 this 3 595  1 n 1 539  
20 0 0 6 30 539 0 0 65 /**
 * Returns 6: the number of faces of a rectangular solid.
 */ 1 4 this 3 595  
21 0 0 7 31 597 0 0 57 /**
 * Creates the nth face of the rectangular solid.
 */ 2 4 this 3 595  1 n 1 539  
22 0 0 7 32 597 0 0 57 /**
 * Returns the nth face of the rectangular solid.
 */ 2 4 this 3 595  1 n 1 539  
23 0 0 4 33 584 0 0 10 /**
 *
 */ 2 4 this 3 594  6 center 1 593  
24 0 0 4 33 584 0 0 10 /**
 *
 */ 4 4 this 3 594  1 x 1 529  1 y 1 529  1 z 1 529  
25 0 0 6 34 593 0 0 10 /**
 *
 */ 1 4 this 3 595  
26 0 0 6 35 593 0 0 10 /**
 *
 */ 1 4 this 3 595  
27 0 0 6 36 593 0 0 10 /**
 *
 */ 1 4 this 3 595  
28 0 0 7 37 598 0 0 10 /**
 *
 */ 1 4 this 3 595  
29 0 0 7 45 592 0 0 0 0 
30 0 0 7 48 599 301 0 10 /**
 *
 */ 3 1 a 1 593  2 db 1 593  6 radius 1 529  
31 0 0 7 48 599 301 0 10 /**
 *
 */ 7 2 ax 1 529  2 ay 1 529  2 az 1 529  2 bx 1 529  2 by 1 529  2 bz 1 529  6 radius 1 529  
32 0 0 4 49 584 0 0 10 /**
 *
 */ 2 4 this 3 599  1 a 1 593  
33 0 0 4 49 584 0 0 10 /**
 *
 */ 4 4 this 3 599  1 x 1 529  1 y 1 529  1 z 1 529  
34 0 0 6 50 593 0 0 10 /**
 *
 */ 1 4 this 3 600  
35 0 0 4 51 584 0 0 10 /**
 *
 */ 2 4 this 3 599  1 b 1 593  
36 0 0 4 51 584 0 0 10 /**
 *
 */ 4 4 this 3 599  1 x 1 529  1 y 1 529  1 z 1 529  
37 0 0 6 52 593 0 0 10 /**
 *
 */ 1 4 this 3 600  
38 0 0 4 53 584 0 0 10 /**
 *
 */ 2 4 this 3 599  6 radius 1 529  
39 0 0 6 54 529 0 0 10 /**
 *
 */ 1 4 this 3 600  
40 0 0 7 60 592 0 0 0 0 
41 0 0 7 65 604 304 0 0 1 6 param0 0 602  
42 0 0 7 64 592 0 0 0 0 
43 0 0 7 69 550 0 0 10 /**
 *
 */ 1 4 name 1 605  
44 0 0 4 70 584 0 0 98 /**
 * Simultaneously sets both the "from" and "into" CollideMask values to the
 * same thing.
 */ 2 4 this 3 550  4 mask 1 606  
45 0 0 4 71 584 0 0 222 /**
 * Sets the "from" CollideMask.  In order for a collision to be detected from
 * this object into another object, the intersection of this object's "from"
 * mask and the other object's "into" mask must be nonzero.
 */ 2 4 this 3 550  4 mask 1 606  
46 0 0 4 72 584 0 0 222 /**
 * Sets the "into" CollideMask.  In order for a collision to be detected from
 * another object into this object, the intersection of the other object's
 * "from" mask and this object's "into" mask must be nonzero.
 */ 2 4 this 3 550  4 mask 1 606  
47 0 0 7 73 606 0 0 233 /**
 * Returns the current "from" CollideMask.  In order for a collision to be
 * detected from this object into another object, the intersection of this
 * object's "from" mask and the other object's "into" mask must be nonzero.
 */ 1 4 this 3 607  
48 0 0 7 74 606 0 0 233 /**
 * Returns the current "into" CollideMask.  In order for a collision to be
 * detected from another object into this object, the intersection of the
 * other object's "from" mask and this object's "into" mask must be nonzero.
 */ 1 4 this 3 607  
49 0 0 4 80 584 0 0 44 /**
 * Removes all solids from the node.
 */ 1 4 this 3 550  
50 0 0 6 81 609 0 0 10 /**
 *
 */ 1 4 this 3 607  
51 0 0 7 82 548 0 0 10 /**
 *
 */ 2 4 this 3 607  1 n 1 609  
52 0 0 7 84 583 0 0 10 /**
 *
 */ 2 4 this 3 550  1 n 1 609  
53 0 0 4 85 584 0 0 55 /**
 * Replaces the solid with the indicated index.
 */ 3 4 this 3 550  1 n 1 609  5 solid 1 583  
54 0 0 4 86 584 0 0 77 /**
 * Inserts the indicated solid to the node at the indicated position.
 */ 3 4 this 3 550  1 n 1 609  5 solid 1 548  
55 0 0 4 87 584 0 0 110 /**
 * Removes the solid with the indicated index.  This will shift all subsequent
 * indices down by one.
 */ 2 4 this 3 550  1 n 1 609  
56 0 0 6 88 609 0 0 121 /**
 * Adds the indicated solid to the node.  Returns the index of the new solid
 * within the node's list of solids.
 */ 2 4 this 3 550  5 solid 1 548  
57 0 0 6 91 539 0 0 114 /**
 * Returns the collider_sort value that has been set for this particular node.
 * See set_collider_sort().
 */ 1 4 this 3 607  
58 0 0 4 92 584 0 0 594 /**
 * Sets a particular collider_sort value on this node.  This controls the
 * order in which colliders (that is, "from nodes") are grouped together for
 * the collision traversal.
 *
 * If there are 32 or fewer colliders added to any particular
 * CollisionTraverser, then this value has no meaning.  It is only useful if
 * there are many colliders, which may force the CollisionTraverser to make
 * multiple passes through the data; in that case, it may be a useful
 * optimization to group colliders that have similar bounding volumes together
 * (by giving them similar sort values).
 */ 2 4 this 3 550  4 sort 1 539  
59 0 0 7 95 606 0 0 80 /**
 * Returns the default into_collide_mask assigned to new CollisionNodes.
 */ 0 
60 0 0 7 97 592 0 0 0 0 
61 0 0 7 100 613 324 0 0 1 6 param0 0 611  
62 0 0 7 100 613 324 0 10 /**
 *
 */ 1 4 name 1 605  
63 0 0 4 102 584 0 0 370 /**
 * Sets the flag that indicates whether the prev_transform stored on a node
 * (as updated via set_fluid_pos(), etc.) is respected to calculate
 * collisions.  If this is true, certain types of collision tests will be
 * enhanced by the information about objects in motion.  If this is false,
 * objects are always considered to be static.  The default is false.
 */ 2 4 this 3 613  4 flag 1 522  
64 0 0 6 103 522 0 0 162 /**
 * Returns the flag that indicates whether the prev_transform stored on a node
 * is respected to calculate collisions.  See set_respect_prev_transform().
 */ 1 4 this 3 611  
65 0 0 4 105 584 0 0 437 /**
 * Adds a new CollisionNode, representing an object that will be tested for
 * collisions into other objects, along with the handler that will serve each
 * detected collision.  Each CollisionNode may be served by only one handler
 * at a time, but a given handler may serve many CollisionNodes.
 *
 * The handler that serves a particular node may be changed from time to time
 * by calling add_collider() again on the same node.
 */ 3 4 this 3 613  8 collider 1 614  7 handler 1 604  
66 0 0 6 106 522 0 0 263 /**
 * Removes the collider (and its associated handler) from the set of
 * CollisionNodes that will be tested each frame for collisions into other
 * objects.  Returns true if the definition was found and removed, false if it
 * wasn't present to begin with.
 */ 2 4 this 3 613  8 collider 1 614  
67 0 0 6 107 522 0 0 145 /**
 * Returns true if the indicated node is current in the set of nodes that will
 * be tested each frame for collisions into other objects.
 */ 2 4 this 3 611  8 collider 1 614  
68 0 0 6 108 539 0 0 108 /**
 * Returns the number of CollisionNodes that have been added to the traverser
 * via add_collider().
 */ 1 4 this 3 611  
69 0 0 7 109 615 0 0 100 /**
 * Returns the nth CollisionNode that has been added to the traverser via
 * add_collider().
 */ 2 4 this 3 611  1 n 1 539  
70 0 0 7 111 604 304 0 169 /**
 * Returns the handler that is currently assigned to serve the indicated
 * collision node, or NULL if the node is not on the traverser's set of active
 * nodes.
 */ 2 4 this 3 611  8 collider 1 614  
71 0 0 4 112 584 0 0 90 /**
 * Completely empties the set of collision nodes and their associated
 * handlers.
 */ 1 4 this 3 613  
72 0 0 4 115 584 0 0 10 /**
 *
 */ 2 4 this 3 613  4 root 1 614  
73 0 0 4 116 584 0 0 777 /**
 * Uses the indicated CollisionRecorder object to start recording the
 * intersection tests made by each subsequent call to traverse() on this
 * object.  A particular CollisionRecorder object can only record one
 * traverser at a time; if this object has already been assigned to another
 * traverser, that assignment is broken.
 *
 * This is intended to be used in a debugging mode to try to determine what
 * work is being performed by the collision traversal.  Usually, attaching a
 * recorder will impose significant runtime overhead.
 *
 * This does not transfer ownership of the CollisionRecorder pointer;
 * maintenance of that remains the caller's responsibility.  If the
 * CollisionRecorder is destructed, it will cleanly remove itself from the
 * traverser.
 */ 2 4 this 3 613  8 recorder 1 543  
74 0 0 6 117 522 0 0 120 /**
 * Returns true if the CollisionTraverser has a CollisionRecorder object
 * currently assigned, false otherwise.
 */ 1 4 this 3 611  
75 0 0 6 118 543 0 0 99 /**
 * Returns the CollisionRecorder currently assigned, or NULL if no recorder is
 * assigned.
 */ 1 4 this 3 611  
76 0 0 4 119 584 0 0 107 /**
 * Removes the CollisionRecorder from the traverser and restores normal low-
 * overhead operation.
 */ 1 4 this 3 613  
77 0 0 7 126 551 0 0 300 /**
 * This is a high-level function to create a CollisionVisualizer object to
 * render the collision tests performed by this traverser.  The supplied root
 * should be any node in the scene graph; typically, the top node (e.g.
 * render).  The CollisionVisualizer will be attached to this node.
 */ 2 4 this 3 613  4 root 1 614  
78 0 0 4 127 584 0 0 69 /**
 * Undoes the effect of a previous call to show_collisions().
 */ 1 4 this 3 613  
79 0 0 4 128 584 0 0 10 /**
 *
 */ 2 4 this 3 611  3 out 1 589  
80 0 0 4 129 584 0 0 10 /**
 *
 */ 3 4 this 3 611  3 out 1 589  12 indent_level 1 539  
81 0 0 7 130 592 0 0 0 0 
82 0 0 4 124 584 0 0 10 /**
 *
 */ 2 4 this 3 616  3 out 1 589  
83 0 0 7 125 592 0 0 0 0 
84 0 0 7 133 548 0 0 104 /**
 * Returns the CollisionSolid pointer for the particular solid that triggered
 * this collision.
 */ 1 4 this 3 618  
85 0 0 6 134 522 0 0 288 /**
 * Returns true if the "into" solid is, in fact, a CollisionSolid, and its
 * pointer is known (in which case get_into() may be called to retrieve it).
 * If this returns false, the collision was detected into a GeomNode, and
 * there is no CollisionSolid pointer to be retrieved.
 */ 1 4 this 3 618  
86 0 0 7 135 548 0 0 243 /**
 * Returns the CollisionSolid pointer for the particular solid was collided
 * into.  This pointer might be NULL if the collision was into a piece of
 * visible geometry, instead of a normal CollisionSolid collision; see
 * has_into().
 */ 1 4 this 3 618  
87 0 0 7 136 550 0 0 182 /**
 * Returns the node that contains the CollisionSolid that triggered this
 * collision.  This will be a node that has been added to a CollisionTraverser
 * via add_collider().
 */ 1 4 this 3 618  
88 0 0 7 137 551 0 0 254 /**
 * Returns the node that contains the CollisionSolid that was collided into.
 * This returns a PandaNode pointer instead of something more specific,
 * because it might be either a CollisionNode or a GeomNode.
 *
 * Also see get_into_node_path().
 */ 1 4 this 3 618  
89 0 0 7 138 615 0 0 224 /**
 * Returns the NodePath that represents the CollisionNode that contains the
 * CollisionSolid that triggered this collision.  This will be a NodePath that
 * has been added to a CollisionTraverser via add_collider().
 */ 1 4 this 3 618  
90 0 0 7 139 615 0 0 338 /**
 * Returns the NodePath that represents the specific CollisionNode or GeomNode
 * instance that was collided into.  This is the same node returned by
 * get_into_node(), represented as a NodePath; however, it may be more useful
 * because the NodePath can resolve the particular instance of the node, if
 * there is more than one.
 */ 1 4 this 3 618  
91 0 0 4 140 584 0 0 82 /**
 * Sets a time value for this collision relative to other CollisionEntries
 */ 2 4 this 3 571  1 t 1 529  
92 0 0 6 141 529 0 0 83 /**
 * returns time value for this collision relative to other CollisionEntries
 */ 1 4 this 3 618  
93 0 0 6 142 522 0 0 188 /**
 * returns true if this represents an actual collision as opposed to a
 * potential collision, needed for iterative collision resolution where path
 * of collider changes mid-frame
 */ 1 4 this 3 618  
94 0 0 4 143 584 0 0 45 /**
 * prepare for another collision test
 */ 1 4 this 3 571  
95 0 0 6 144 522 0 0 203 /**
 * Returns true if the collision was detected by a CollisionTraverser whose
 * respect_prev_transform flag was set true, meaning we should consider motion
 * significant in evaluating collisions.
 */ 1 4 this 3 618  
96 0 0 4 145 584 0 0 178 /**
 * Stores the point, on the surface of the "into" object, at which a collision
 * is detected.
 *
 * This point is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 571  5 point 1 593  
97 0 0 4 146 584 0 0 171 /**
 * Stores the surface normal of the "into" object at the point of the
 * intersection.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 571  6 normal 1 585  
98 0 0 4 147 584 0 0 352 /**
 * Stores the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).
 *
 * This point is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 571  5 point 1 593  
99 0 0 6 148 522 0 0 174 /**
 * Returns true if the surface point has been specified, false otherwise.  See
 * get_surface_point().  Some types of collisions may not compute the surface
 * point.
 */ 1 4 this 3 618  
100 0 0 6 149 522 0 0 176 /**
 * Returns true if the surface normal has been specified, false otherwise.
 * See get_surface_normal().  Some types of collisions may not compute the
 * surface normal.
 */ 1 4 this 3 618  
101 0 0 6 150 522 0 0 176 /**
 * Returns true if the interior point has been specified, false otherwise.
 * See get_interior_point().  Some types of collisions may not compute the
 * interior point.
 */ 1 4 this 3 618  
102 0 0 4 151 584 0 0 190 /**
 * Stores the position of the "from" object at the instant at which the
 * collision is first detected.
 *
 * This position is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 571  3 pos 1 593  
103 0 0 4 152 584 0 0 154 /**
 * Stores the surface normal of the "into" object at the contact pos.
 *
 * This normal is specified in the coordinate space of the "into" object.
 */ 2 4 this 3 571  6 normal 1 585  
104 0 0 6 153 522 0 0 172 /**
 * Returns true if the contact position has been specified, false otherwise.
 * See get_contact_pos().  Some types of collisions may not compute the
 * contact pos.
 */ 1 4 this 3 618  
105 0 0 6 154 522 0 0 176 /**
 * Returns true if the contact normal has been specified, false otherwise.
 * See get_contact_normal().  Some types of collisions may not compute the
 * contact normal.
 */ 1 4 this 3 618  
106 0 0 7 155 582 0 0 330 /**
 * Returns the point, on the surface of the "into" object, at which a
 * collision is detected.  This can be thought of as the first point of
 * intersection.  However the contact point is the actual first point of
 * intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 618  5 space 1 614  
107 0 0 7 156 598 0 0 200 /**
 * Returns the surface normal of the "into" object at the point at which a
 * collision is detected.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 618  5 space 1 614  
108 0 0 7 157 582 0 0 431 /**
 * Returns the point, within the interior of the "into" object, which
 * represents the depth to which the "from" object has penetrated.  This can
 * also be described as the intersection point on the surface of the "from"
 * object (which is inside the "into" object).  It can be thought of as the
 * deepest point of intersection.
 *
 * The point will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 618  5 space 1 614  
109 0 0 6 158 522 0 0 244 /**
 * Simultaneously transforms the surface point, surface normal, and interior
 * point of the collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */ 5 4 this 3 618  5 space 1 614  13 surface_point 1 582  14 surface_normal 1 598  14 interior_point 1 582  
110 0 0 7 159 582 0 0 200 /**
 * Returns the position of the "from" object at the instant that a collision
 * is first detected.
 *
 * The position will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 618  5 space 1 614  
111 0 0 7 160 598 0 0 175 /**
 * Returns the surface normal of the "into" object at the contact position.
 *
 * The normal will be converted into whichever coordinate space the caller
 * specifies.
 */ 2 4 this 3 618  5 space 1 614  
112 0 0 6 161 522 0 0 230 /**
 * Simultaneously transforms the contact position and contact normal of the
 * collision into the indicated coordinate space.
 *
 * Returns true if all three properties are available, or false if any one of
 * them is not.
 */ 4 4 this 3 618  5 space 1 614  11 contact_pos 1 582  14 contact_normal 1 598  
113 0 0 4 162 584 0 0 10 /**
 *
 */ 2 4 this 3 618  3 out 1 589  
114 0 0 4 163 584 0 0 10 /**
 *
 */ 3 4 this 3 618  3 out 1 589  12 indent_level 1 539  
115 0 0 7 176 592 0 0 0 0 
116 0 0 7 179 622 386 0 10 /**
 *
 */ 1 4 copy 1 620  
117 0 0 7 179 622 386 0 10 /**
 *
 */ 1 5 plane 1 623  
118 0 0 7 180 598 0 0 10 /**
 *
 */ 1 4 this 3 620  
119 0 0 6 181 529 0 0 10 /**
 *
 */ 2 4 this 3 620  5 point 1 593  
120 0 0 4 182 584 0 0 10 /**
 *
 */ 2 4 this 3 622  5 plane 1 623  
121 0 0 6 183 623 0 0 10 /**
 *
 */ 1 4 this 3 620  
122 0 0 4 184 584 0 0 57 /**
 * Convenience method to flip the plane in-place.
 */ 1 4 this 3 622  
123 0 0 7 190 592 0 0 0 0 
124 0 0 7 193 624 395 0 144 /**
 * This is only for the convenience of CollisionPolygon.  Normally, you should
 * not attempt to create an uninitialized CollisionPlane.
 */ 0 
125 0 0 4 194 584 0 0 47 /**
 * store away a vertex to index against
 */ 2 4 this 3 624  4 vert 1 593  
126 0 0 4 195 584 0 0 42 /**
 * store a triangle for processing
 */ 4 4 this 3 624  6 pointA 1 625  6 pointB 1 625  6 pointC 1 625  
127 0 0 6 196 625 0 0 0 1 4 this 3 626  
128 0 0 6 197 593 0 0 0 2 4 this 3 626  5 index 1 625  
129 0 0 6 199 625 0 0 0 1 4 this 3 626  
130 0 0 7 200 628 0 0 0 2 4 this 3 626  5 index 1 625  
131 0 0 7 205 592 0 0 0 0 
132 0 0 7 208 633 403 0 10 /**
 *
 */ 3 1 a 1 629  1 b 1 629  1 c 1 629  
133 0 0 7 208 633 403 0 10 /**
 *
 */ 4 1 a 1 629  1 b 1 629  1 c 1 629  1 d 1 629  
134 0 0 6 209 609 0 0 66 /**
 * Returns the number of vertices of the CollisionPolygon.
 */ 1 4 this 3 634  
135 0 0 7 210 582 0 0 82 /**
 * Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.
 */ 2 4 this 3 634  1 n 1 609  
136 0 0 6 212 522 0 0 167 /**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */ 3 1 a 1 593  1 b 1 593  1 c 1 593  
137 0 0 6 212 522 0 0 167 /**
 * Verifies that the indicated set of points will define a valid
 * CollisionPolygon: that is, at least three non-collinear points, with no
 * points repeated.
 */ 4 1 a 1 593  1 b 1 593  1 c 1 593  1 d 1 593  
138 0 0 6 213 522 0 0 122 /**
 * Returns true if the CollisionPolygon is valid (that is, it has at least
 * three vertices), or false otherwise.
 */ 1 4 this 3 634  
139 0 0 6 214 522 0 0 106 /**
 * Returns true if the CollisionPolygon appears to be concave, or false if it
 * is safely convex.
 */ 1 4 this 3 634  
140 0 0 7 218 592 0 0 0 0 
141 0 0 7 221 636 423 0 168 /**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */ 0 
142 0 0 7 221 636 423 0 0 1 6 param0 0 637  
143 0 0 4 222 584 0 0 80 /**
 * Removes all of the previously-added in patterns.  See add_in_pattern.
 */ 1 4 this 3 636  
144 0 0 4 223 584 0 0 1586 /**
 * Adds a pattern string to the list of events that will be generated in
 * response to a collision.  The pattern string describes how the event name
 * will be composed.  It is a string that may contain any of the following:
 *
 * %fn  - the name of the "from" object's node %in  - the name of the "into"
 * object's node %fs  - 't' if "from" is tangible, 'i' if intangible %is  -
 * 't' if "into" is tangible, 'i' if intangible %ig  - 'c' if the collision is
 * into a CollisionNode, 'g' if it is a geom.
 *
 * %(tag)fh - generate event only if "from" node has the indicated net tag.
 * %(tag)fx - generate event only if "from" node does not have the indicated
 * net tag.  %(tag)ih - generate event only if "into" node has the indicated
 * net tag.  %(tag)ix - generate event only if "into" node does not have the
 * indicated net tag.  %(tag)ft - the indicated net tag value of the "from"
 * node.  %(tag)it - the indicated net tag value of the "into" node.
 *
 * Parentheses in the above are literal and should be included in the actual
 * pattern.
 *
 * The event name will be based on the in_pattern string specified here, with
 * all occurrences of the above strings replaced with the corresponding
 * values.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */ 2 4 this 3 636  10 in_pattern 1 605  
145 0 0 4 224 584 0 0 189 /**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_in_pattern() instead.
 */ 2 4 this 3 636  10 in_pattern 1 605  
146 0 0 6 225 539 0 0 73 /**
 * Returns the number of in pattern strings that have been added.
 */ 1 4 this 3 637  
147 0 0 6 226 605 0 0 145 /**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_in_pattern().
 */ 2 4 this 3 637  1 n 1 539  
148 0 0 4 228 584 0 0 83 /**
 * Removes all of the previously-added in patterns.  See add_again_pattern.
 */ 1 4 this 3 636  
149 0 0 4 229 584 0 0 649 /**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *still* detected.  This
 * event is thrown each consecutive time a collision between two particular
 * nodes is detected, starting with the second time.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */ 2 4 this 3 636  13 again_pattern 1 605  
150 0 0 4 230 584 0 0 192 /**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_again_pattern() instead.
 */ 2 4 this 3 636  13 again_pattern 1 605  
151 0 0 6 231 539 0 0 73 /**
 * Returns the number of in pattern strings that have been added.
 */ 1 4 this 3 637  
152 0 0 6 232 605 0 0 148 /**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_again_pattern().
 */ 2 4 this 3 637  1 n 1 539  
153 0 0 4 234 584 0 0 81 /**
 * Removes all of the previously-added in patterns.  See add_out_pattern.
 */ 1 4 this 3 636  
154 0 0 4 235 584 0 0 518 /**
 * Adds the pattern string that indicates how the event names are generated
 * when a collision between two particular nodes is *no longer* detected.
 *
 * In general, the in_pattern event is thrown on the first detection of a
 * collision between two particular nodes.  In subsequent passes, as long as a
 * collision between those two nodes continues to be detected each frame, the
 * again_pattern is thrown.  The first frame in which the collision is no
 * longer detected, the out_pattern event is thrown.
 */ 2 4 this 3 636  11 out_pattern 1 605  
155 0 0 4 236 584 0 0 190 /**
 * This method is deprecated; it completely replaces all the in patterns that
 * have previously been set with the indicated pattern.
 *
 * @deprecated Use add_out_pattern() instead.
 */ 2 4 this 3 636  11 out_pattern 1 605  
156 0 0 6 237 539 0 0 73 /**
 * Returns the number of in pattern strings that have been added.
 */ 1 4 this 3 637  
157 0 0 6 238 605 0 0 146 /**
 * Returns the nth pattern string that indicates how the event names are
 * generated for each collision detected.  See add_out_pattern().
 */ 2 4 this 3 637  1 n 1 539  
158 0 0 4 245 584 0 0 541 /**
 * Empties the list of elements that all colliders are known to be colliding
 * with.  No "out" events will be thrown; if the same collision is detected
 * next frame, a new "in" event will be thrown for each collision.
 *
 * This can be called each frame to defeat the persistent "in" event
 * mechanism, which prevents the same "in" event from being thrown repeatedly.
 * However, also see add_again_pattern(), which can be used to set the event
 * that is thrown when a collision is detected for two or more consecutive
 * frames.
 */ 1 4 this 3 636  
159 0 0 4 246 584 0 0 58 /**
 * Same as clear() except "out" events are thrown.
 */ 1 4 this 3 636  
160 0 0 7 247 592 0 0 0 0 
161 0 0 4 250 584 0 0 180 /**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 */ 3 4 this 3 639  8 collider 1 614  6 target 1 614  
162 0 0 4 250 584 0 0 374 /**
 * Adds a new collider to the list with a NodePath that will be updated with
 * the collider's new position, or updates the existing collider with a new
 * NodePath object.
 *
 * The indicated DriveInterface will also be updated with the target's new
 * transform each frame.  This method should be used when the target is
 * directly controlled by a DriveInterface.
 */ 4 4 this 3 639  8 collider 1 614  6 target 1 614  15 drive_interface 1 640  
163 0 0 6 251 522 0 0 92 /**
 * Removes the collider from the list of colliders that this handler knows
 * about.
 */ 2 4 this 3 639  8 collider 1 614  
164 0 0 6 252 522 0 0 94 /**
 * Returns true if the handler knows about the indicated collider, false
 * otherwise.
 */ 2 4 this 3 642  8 collider 1 614  
165 0 0 4 253 584 0 0 77 /**
 * Completely empties the list of colliders this handler knows about.
 */ 1 4 this 3 639  
166 0 0 4 254 584 0 0 269 /**
 * Specifies an arbitrary NodePath that the handler is always considered to be
 * facing.  It does not detect collisions with surfaces that appear to be
 * facing away from this NodePath.  This works best when the collision
 * surfaces in question are polygons.
 */ 2 4 this 3 639  6 center 1 614  
167 0 0 4 255 584 0 0 64 /**
 * Clears the center NodePath specified with set_center.
 */ 1 4 this 3 639  
168 0 0 6 256 614 0 0 114 /**
 * Returns the NodePath specified with set_center, or the empty NodePath if
 * nothing has been specified.
 */ 1 4 this 3 642  
169 0 0 6 257 522 0 0 95 /**
 * Returns true if a NodePath has been specified with set_center(), false
 * otherwise.
 */ 1 4 this 3 642  
170 0 0 6 258 522 0 0 255 /**
 * Did the handler make any contacts with anything on the last collision pass?
 * Depending on how your world is setup, this can be used to tell if the
 * handler is out of the world (i.e.  out of bounds). That is the original use
 * of this call.
 */ 1 4 this 3 642  
171 0 0 7 261 592 0 0 0 0 
172 0 0 7 263 644 423 0 10 /**
 *
 */ 0 
173 0 0 4 264 584 0 0 166 /**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 2 4 this 3 644  6 offset 1 529  
174 0 0 6 265 529 0 0 169 /**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 1 4 this 3 645  
175 0 0 4 266 584 0 0 82 /**
 * Sets the reach to add to (or subtract from) the highest collision point
 */ 2 4 this 3 644  5 reach 1 529  
176 0 0 6 267 529 0 0 85 /**
 * Returns the reach to add to (or subtract from) the highest collision point
 */ 1 4 this 3 645  
177 0 0 4 268 584 0 0 199 /**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */ 2 4 this 3 644  7 max_vel 1 529  
178 0 0 6 269 529 0 0 160 /**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */ 1 4 this 3 645  
179 0 0 7 273 592 0 0 0 0 
180 0 0 7 275 647 423 0 10 /**
 *
 */ 0 
181 0 0 4 276 584 0 0 10 /**
 *
 */ 2 4 this 3 647  4 flag 1 522  
182 0 0 6 277 522 0 0 10 /**
 *
 */ 1 4 this 3 648  
183 0 0 7 279 592 0 0 0 0 
184 0 0 7 281 650 448 0 10 /**
 *
 */ 0 
185 0 0 7 282 592 0 0 0 0 
186 0 0 7 285 651 423 0 10 /**
 *
 */ 0 
187 0 0 4 286 584 0 0 166 /**
 * Sets the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 2 4 this 3 651  6 offset 1 529  
188 0 0 6 287 529 0 0 169 /**
 * Returns the linear offset to add to (or subtract from) the highest detected
 * collision point to determine the actual height at which to set the
 * collider.
 */ 1 4 this 3 652  
189 0 0 4 288 584 0 0 82 /**
 * Sets the reach to add to (or subtract from) the highest collision point
 */ 2 4 this 3 651  5 reach 1 529  
190 0 0 6 289 529 0 0 85 /**
 * Returns the reach to add to (or subtract from) the highest collision point
 */ 1 4 this 3 652  
191 0 0 6 290 529 0 0 238 /**
 * Return the height of the object from the ground.
 *
 * The object might not necessarily be at rest.  Use is_on_ground() if you
 * want to know whether the object is on the ground and at rest.
 *
 * See Also: is_in_outer_space()
 */ 1 4 this 3 652  
192 0 0 6 291 522 0 0 33 /**
 * Is the object at rest?
 */ 1 4 this 3 652  
193 0 0 6 292 529 0 0 282 /**
 * How hard did the object hit the ground.  This value is set on impact with
 * the ground.  You may want to watch (poll) on is_on_groun() and when that is
 * true, call get_impact_velocity(). Normally I avoid polling, but we are
 * calling is_on_ground() frequently anyway.
 */ 1 4 this 3 652  
194 0 0 6 293 585 0 0 10 /**
 *
 */ 1 4 this 3 652  
195 0 0 4 294 584 0 0 184 /**
 * Adds the sepcified amount to the current velocity.  This is mostly here
 * allow this common operation to be faster for scripting, but it's also more
 * concise even in cpp.
 */ 2 4 this 3 651  8 velocity 1 529  
196 0 0 4 295 584 0 0 46 /**
 * Sets the current vertical velocity.
 */ 2 4 this 3 651  8 velocity 1 529  
197 0 0 6 296 529 0 0 354 /**
 * Gets the current vertical velocity.
 *
 * Generally, negative values mean the object is in free fall; while postive
 * values mean the object has vertical thrust.
 *
 * A zero value does not necessarily mean the object on the ground, it may
 * also be weightless and/or at the apex of its jump.
 *
 * See Also: is_on_ground() and get_gravity()
 */ 1 4 this 3 652  
198 0 0 4 297 584 0 0 56 /**
 * Sets the linear gravity force (always plumb).
 */ 2 4 this 3 651  7 gravity 1 529  
199 0 0 6 298 529 0 0 56 /**
 * Gets the linear gravity force (always plumb).
 */ 1 4 this 3 652  
200 0 0 4 299 584 0 0 199 /**
 * Sets the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  Set this to zero to allow
 * it to instantly teleport any distance.
 */ 2 4 this 3 651  7 max_vel 1 529  
201 0 0 6 300 529 0 0 160 /**
 * Retrieves the maximum speed at which the object will be allowed to descend
 * towards a floor below it, in units per second.  See set_max_velocity().
 */ 1 4 this 3 652  
202 0 0 4 301 584 0 0 229 /**
 * Enables old behavior required by Toontown (Sellbot Factory lava room is
 * good test case, lava and conveyor belt specifically). Behavior is to throw
 * enter/exit events only for floor that the toon is in contact with
 */ 2 4 this 3 651  11 legacy_mode 1 522  
203 0 0 6 302 522 0 0 49 /**
 * returns true if legacy mode is enabled
 */ 1 4 this 3 652  
204 0 0 7 313 592 0 0 0 0 
205 0 0 7 315 654 470 0 168 /**
 * The default CollisionHandlerEvent will throw no events.  Its pattern
 * strings must first be set via a call to add_in_pattern() and/or
 * add_out_pattern().
 */ 0 
206 0 0 7 315 654 470 0 0 1 6 param0 0 655  
207 0 0 7 316 592 0 0 0 0 
208 0 0 7 319 657 479 0 10 /**
 *
 */ 0 
209 0 0 7 319 657 479 0 0 1 6 param0 0 658  
210 0 0 4 320 584 0 0 257 /**
 * Sorts all the detected collisions front-to-back by
 * from_intersection_point() so that those intersection points closest to the
 * collider's origin (e.g., the center of the CollisionSphere, or the point_a
 * of a CollisionSegment) appear first.
 */ 1 4 this 3 657  
211 0 0 4 321 584 0 0 50 /**
 * Removes all the entries from the queue.
 */ 1 4 this 3 657  
212 0 0 6 322 539 0 0 69 /**
 * Returns the number of CollisionEntries detected last pass.
 */ 1 4 this 3 658  
213 0 0 7 323 571 378 0 61 /**
 * Returns the nth CollisionEntry detected last pass.
 */ 2 4 this 3 658  1 n 1 539  
214 0 0 4 327 584 0 0 10 /**
 *
 */ 2 4 this 3 658  3 out 1 589  
215 0 0 4 328 584 0 0 10 /**
 *
 */ 3 4 this 3 658  3 out 1 589  12 indent_level 1 539  
216 0 0 7 329 592 0 0 0 0 
217 0 0 7 332 660 486 0 10 /**
 *
 */ 2 6 center 1 593  6 radius 1 529  
218 0 0 7 332 660 486 0 10 /**
 *
 */ 4 2 cx 1 529  2 cy 1 529  2 cz 1 529  6 radius 1 529  
219 0 0 4 333 584 0 0 10 /**
 *
 */ 2 4 this 3 660  6 center 1 593  
220 0 0 4 333 584 0 0 10 /**
 *
 */ 4 4 this 3 660  1 x 1 529  1 y 1 529  1 z 1 529  
221 0 0 6 334 593 0 0 10 /**
 *
 */ 1 4 this 3 661  
222 0 0 4 335 584 0 0 10 /**
 *
 */ 2 4 this 3 660  6 radius 1 529  
223 0 0 6 336 529 0 0 10 /**
 *
 */ 1 4 this 3 661  
224 0 0 7 339 592 0 0 0 0 
225 0 0 7 342 663 489 0 10 /**
 *
 */ 2 6 center 1 593  6 radius 1 529  
226 0 0 7 342 663 489 0 10 /**
 *
 */ 4 2 cx 1 529  2 cy 1 529  2 cz 1 529  6 radius 1 529  
227 0 0 7 343 592 0 0 0 0 
228 0 0 7 346 664 497 0 183 /**
 * Creates an invalid ray.  This isn't terribly useful; it's expected that the
 * user will subsequently adjust the ray via set_origin()/set_direction() or
 * set_from_lens().
 */ 0 
229 0 0 7 346 664 497 0 10 /**
 *
 */ 2 6 origin 1 593  9 direction 1 585  
230 0 0 7 346 664 497 0 10 /**
 *
 */ 6 2 ox 1 529  2 oy 1 529  2 oz 1 529  2 dx 1 529  2 dy 1 529  2 dz 1 529  
231 0 0 4 347 584 0 0 10 /**
 *
 */ 2 4 this 3 664  6 origin 1 593  
232 0 0 4 347 584 0 0 10 /**
 *
 */ 4 4 this 3 664  1 x 1 529  1 y 1 529  1 z 1 529  
233 0 0 6 348 593 0 0 10 /**
 *
 */ 1 4 this 3 665  
234 0 0 4 350 584 0 0 10 /**
 *
 */ 2 4 this 3 664  9 direction 1 585  
235 0 0 4 350 584 0 0 10 /**
 *
 */ 4 4 this 3 664  1 x 1 529  1 y 1 529  1 z 1 529  
236 0 0 6 351 585 0 0 10 /**
 *
 */ 1 4 this 3 665  
237 0 0 6 353 522 0 0 327 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */ 3 4 this 3 664  6 camera 1 667  5 point 1 669  
238 0 0 6 353 522 0 0 262 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionRay so that it begins at the LensNode's near plane and extends to
 * infinity, making it suitable for picking objects from the screen given a
 * camera and a mouse location.
 */ 4 4 this 3 664  6 camera 1 667  2 px 1 529  2 py 1 529  
239 0 0 7 354 592 0 0 0 0 
240 0 0 7 357 673 500 0 185 /**
 * Creates an invalid line.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the line via set_origin()/set_direction()
 * or set_from_lens().
 */ 0 
241 0 0 7 357 673 500 0 10 /**
 *
 */ 2 6 origin 1 593  9 direction 1 585  
242 0 0 7 357 673 500 0 10 /**
 *
 */ 6 2 ox 1 529  2 oy 1 529  2 oz 1 529  2 dx 1 529  2 dy 1 529  2 dz 1 529  
243 0 0 7 358 592 0 0 0 0 
244 0 0 7 361 674 509 0 39 /**
 * Creates an invalid parabola.
 */ 0 
245 0 0 7 361 674 509 0 110 /**
 * Creates a parabola with the endpoints between t1 and t2 in the parametric
 * space of the parabola.
 */ 3 8 parabola 1 675  2 t1 1 529  2 t2 1 529  
246 0 0 4 362 584 0 0 57 /**
 * Replaces the parabola specified by this solid.
 */ 2 4 this 3 674  8 parabola 1 675  
247 0 0 6 363 675 0 0 56 /**
 * Returns the parabola specified by this solid.
 */ 1 4 this 3 676  
248 0 0 4 364 584 0 0 54 /**
 * Changes the starting point on the parabola.
 */ 2 4 this 3 674  2 t1 1 529  
249 0 0 6 365 529 0 0 54 /**
 * Returns the starting point on the parabola.
 */ 1 4 this 3 676  
250 0 0 4 366 584 0 0 52 /**
 * Changes the ending point on the parabola.
 */ 2 4 this 3 674  2 t2 1 529  
251 0 0 6 367 529 0 0 52 /**
 * Returns the ending point on the parabola.
 */ 1 4 this 3 676  
252 0 0 7 374 592 0 0 0 0 
253 0 0 7 377 678 517 0 191 /**
 * Creates an invalid segment.  This isn't terribly useful; it's expected that
 * the user will subsequently adjust the segment via
 * set_origin()/set_direction() or set_from_lens().
 */ 0 
254 0 0 7 377 678 517 0 10 /**
 *
 */ 2 1 a 1 593  2 db 1 593  
255 0 0 7 377 678 517 0 10 /**
 *
 */ 6 2 ax 1 529  2 ay 1 529  2 az 1 529  2 bx 1 529  2 by 1 529  2 bz 1 529  
256 0 0 4 378 584 0 0 10 /**
 *
 */ 2 4 this 3 678  1 a 1 593  
257 0 0 4 378 584 0 0 10 /**
 *
 */ 4 4 this 3 678  1 x 1 529  1 y 1 529  1 z 1 529  
258 0 0 6 379 593 0 0 10 /**
 *
 */ 1 4 this 3 679  
259 0 0 4 380 584 0 0 10 /**
 *
 */ 2 4 this 3 678  1 b 1 593  
260 0 0 4 380 584 0 0 10 /**
 *
 */ 4 4 this 3 678  1 x 1 529  1 y 1 529  1 z 1 529  
261 0 0 6 381 593 0 0 10 /**
 *
 */ 1 4 this 3 679  
262 0 0 6 382 522 0 0 336 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 *
 * Returns true if the point was acceptable, false otherwise.
 */ 3 4 this 3 678  6 camera 1 667  5 point 1 669  
263 0 0 6 382 522 0 0 271 /**
 * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the
 * CollisionSegment so that it begins at the LensNode's near plane and extends
 * to the far plane, making it suitable for picking objects from the screen
 * given a camera and a mouse location.
 */ 4 4 this 3 678  6 camera 1 667  2 px 1 529  2 py 1 529  
264 0 0 7 385 592 0 0 0 0 
163
518 14 CollisionSolid 0 75777 14 CollisionSolid 14 CollisionSolid 0 0 0 0 0 4 681 682 683 684 14 265 266 267 268 269 270 271 272 273 274 275 276 277 278 0 0 1 0 519 0 0 0 0 457
/**
 * The abstract base class for all things that can collide with other things
 * in the world, and all the things they can collide with (except geometry).
 *
 * This class and its derivatives really work very similarly to the way
 * BoundingVolume and all of its derivatives work.  There's a different
 * subclass for each basic shape of solid, and double-dispatch function calls
 * handle the subset of the N*N intersection tests that we care about.
 */

519 17 CopyOnWriteObject 0 2048 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 0 0 0 0 0 0 0 0 169
/**
 * This base class provides basic reference counting, but also can be used
 * with a CopyOnWritePointer to provide get_read_pointer() and
 * get_write_pointer().
 */

520 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 521 0 0 0 0 0 0 0 0 0 0

521 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

522 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

523 32 ConstPointerTo< BoundingVolume > 0 2048 32 ConstPointerTo< BoundingVolume > 32 ConstPointerTo< BoundingVolume > 0 0 0 0 0 0 0 0 0 0 0 0 0

524 12 CollisionBox 0 141313 12 CollisionBox 12 CollisionBox 0 0 0 1 279 292 4 685 686 687 688 12 280 281 282 283 284 285 286 287 288 289 290 291 0 0 1 0 518 0 0 0 0 47
/**
 * A cuboid collision volume or object.
 */

525 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 520 0 0 0 0 0 0 0 0 0 0

526 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 527 0 0 0 0 0 0 0 0 0 0

527 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

528 16 CollisionCapsule 0 141313 16 CollisionCapsule 16 CollisionCapsule 0 0 0 1 293 301 3 689 690 691 7 294 295 296 297 298 299 300 0 0 1 0 518 0 0 0 0 201
/**
 * This implements a solid consisting of a cylinder with hemispherical endcaps,
 * also known as a capsule or a spherocylinder.
 *
 * This shape was previously erroneously called CollisionTube.
 */

529 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 530 0 0 0 0 0 0 0 0 0 0

530 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

531 16 CollisionHandler 0 141313 16 CollisionHandler 16 CollisionHandler 0 0 0 1 303 304 0 1 302 0 0 1 0 532 0 0 0 0 262
/**
 * The abstract interface to a number of classes that decide what to do when a
 * collision is detected.  One of these must be assigned to the
 * CollisionTraverser that is processing collisions in order to specify how to
 * dispatch detected collisions.
 */

532 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

533 13 CollisionNode 0 75777 13 CollisionNode 13 CollisionNode 0 0 0 1 305 0 5 692 693 694 695 696 17 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 1 742 0 1 0 534 0 0 0 0 261
/**
 * A node in the scene graph that can hold any number of CollisionSolids.
 * This may either represent a bit of static geometry in the scene that things
 * will collide with, or an animated object twirling around in the world and
 * running into things.
 */

534 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175
/**
 * A basic node of the scene graph or data graph.  This is the base class of
 * all specialized nodes, and also serves as a generic node with no special
 * properties.
 */

535 11 CollideMask 0 2105344 11 CollideMask 11 CollideMask 0 0 536 0 0 0 0 0 0 0 0 0 0

536 9 BitMask32 0 2105344 9 BitMask32 9 BitMask32 0 0 537 0 0 0 0 0 0 0 0 0 0

537 23 BitMask< uint32_t, 32 > 0 2048 23 BitMask< uint32_t, 32 > 23 BitMask< uint32_t, 32 > 0 0 0 0 0 0 0 0 0 0 0 0 0

538 32 ConstPointerTo< CollisionSolid > 0 2048 32 ConstPointerTo< CollisionSolid > 32 ConstPointerTo< CollisionSolid > 0 0 0 0 0 0 0 0 0 0 0 0 0

539 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

540 18 CollisionTraverser 0 26625 18 CollisionTraverser 18 CollisionTraverser 0 0 0 1 323 324 3 697 698 699 19 325 326 327 328 329 330 331 332 333 334 335 336 337 338 341 342 343 344 345 1 743 0 1 0 541 0 0 0 0 467
/**
 * This class manages the traversal through the scene graph to detect
 * collisions.  It holds ownership of a number of collider objects, each of
 * which is a CollisionNode and an associated CollisionHandler.
 *
 * When traverse() is called, it begins at the indicated root and detects all
 * collisions with any of its collider objects against nodes at or below the
 * indicated root, calling the appropriate CollisionHandler for each detected
 * collision.
 */

541 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

542 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762
/**
 * NodePath is the fundamental system for disambiguating instances, and also
 * provides a higher-level interface for manipulating the scene graph.
 *
 * A NodePath is a list of connected nodes from the root of the graph to any
 * sub-node.  Each NodePath therefore uniquely describes one instance of a
 * node.
 *
 * NodePaths themselves are lightweight objects that may easily be copied and
 * passed by value.  Their data is stored as a series of NodePathComponents
 * that are stored on the nodes.  Holding a NodePath will keep a reference
 * count to all the nodes in the path.  However, if any node in the path is
 * removed or reparented (perhaps through a different NodePath), the NodePath
 * will automatically be updated to reflect the changes.
 */

543 19 CollisionRecorder * 0 8576 19 CollisionRecorder * 19 CollisionRecorder * 0 0 544 0 0 0 0 0 0 0 0 0 0

544 17 CollisionRecorder 0 75777 17 CollisionRecorder 17 CollisionRecorder 0 0 0 0 0 0 2 339 340 0 0 1 0 545 0 0 0 0 206
/**
 * This class is used to help debug the work the collisions system is doing.
 * It is a virtual base class that just provides an interface for recording
 * collisions tested and detected each frame.
 */

545 11 TypedObject 0 2048 11 TypedObject 11 TypedObject 0 0 0 0 0 0 0 0 0 0 0 0 2508
/**
 * This is an abstract class that all classes which use TypeHandle, and also
 * provide virtual functions to support polymorphism, should inherit from.
 * Each derived class should define get_type(), which should return the
 * specific type of the derived class.  Inheriting from this automatically
 * provides support for is_of_type() and is_exact_type().
 *
 * All classes that inherit directly or indirectly from TypedObject should
 * redefine get_type() and force_init_type(), as shown below.  Some classes
 * that do not inherit from TypedObject may still declare TypeHandles for
 * themselves by defining methods called get_class_type() and init_type().
 * Classes such as these may serve as base classes, but the dynamic type
 * identification system will be limited.  Classes that do not inherit from
 * TypedObject need not define the virtual functions get_type() and
 * force_init_type() (or any other virtual functions).
 *
 * There is a specific layout for defining the overrides from this class.
 * Keeping the definitions formatted just like these examples will allow
 * someone in the future to use a sed (or similar) script to make global
 * changes, if necessary.  Avoid rearranging the braces or the order of the
 * functions unless you're ready to change them in every file all at once.
 *
 * What follows are some examples that can be used in new classes that you
 * create.
 *
 * @par In the class definition (.h file):
 * @code
 * public:
 *   static TypeHandle get_class_type() {
 *     return _type_handle;
 *   }
 *   static void init_type() {
 *     <<<BaseClassOne>>>::init_type();
 *     <<<BaseClassTwo>>>::init_type();
 *     <<<BaseClassN>>>::init_type();
 *     register_type(_type_handle, "<<<ThisClassStringName>>>",
 *                   <<<BaseClassOne>>>::get_class_type(),
 *                   <<<BaseClassTwo>>>::get_class_type(),
 *                   <<<BaseClassN>>>::get_class_type());
 *   }
 *   virtual TypeHandle get_type() const {
 *     return get_class_type();
 *   }
 *   virtual TypeHandle force_init_type() {init_type(); return get_class_type();}
 *
 * private:
 *   static TypeHandle _type_handle;
 * @endcode
 *
 * @par In the class .cxx file:
 * @code
 * TypeHandle <<<ThisClassStringName>>>::_type_handle;
 * @endcode
 *
 * @par In the class config_<<<PackageName>>>.cxx file:
 * @code
 * ConfigureFn(config_<<<PackageName>>>) {
 *   <<<ClassOne>>>::init_type();
 *   <<<ClassTwo>>>::init_type();
 *   <<<ClassN>>>::init_type();
 * }
 * @endcode
 */

546 14 CollisionEntry 0 141313 14 CollisionEntry 14 CollisionEntry 0 0 0 0 378 8 700 701 702 703 704 705 706 707 32 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 0 0 1 0 547 0 0 0 0 437
/**
 * Defines a single collision event.  One of these is created for each
 * collision detected by a CollisionTraverser, to be dealt with by the
 * CollisionHandler.
 *
 * A CollisionEntry provides slots for a number of data values (such as
 * intersection point and normal) that might or might not be known for each
 * collision.  It is up to the handler to determine what information is known
 * and to do the right thing with it.
 */

547 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

548 22 CollisionSolid const * 0 8576 22 CollisionSolid const * 22 CollisionSolid const * 0 0 549 0 0 0 0 0 0 0 0 0 0

549 20 CollisionSolid const 0 8832 20 CollisionSolid const 20 CollisionSolid const 0 0 518 0 0 0 0 0 0 0 0 0 0

550 15 CollisionNode * 0 8576 15 CollisionNode * 15 CollisionNode * 0 0 533 0 0 0 0 0 0 0 0 0 0

551 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 534 0 0 0 0 0 0 0 0 0 0

552 14 CollisionPlane 0 141313 14 CollisionPlane 14 CollisionPlane 0 0 0 1 379 386 2 708 709 6 380 381 382 383 384 385 0 0 1 0 518 0 0 0 0 10
/**
 *
 */

553 12 LPlane const 0 8832 12 LPlane const 12 LPlane const 0 0 554 0 0 0 0 0 0 0 0 0 0

554 6 LPlane 0 2105344 6 LPlane 6 LPlane 0 0 555 0 0 0 0 0 0 0 0 0 0

555 7 LPlanef 0 2048 7 LPlanef 7 LPlanef 0 0 0 0 0 0 0 0 0 0 0 0 120
/**
 * An abstract mathematical description of a plane.  A plane is defined by the
 * equation Ax + By + Cz + D = 0.
 */

556 18 CollisionFloorMesh 0 141313 18 CollisionFloorMesh 18 CollisionFloorMesh 0 0 0 1 387 395 2 710 711 7 388 389 390 391 392 393 394 2 744 745 0 1 0 518 0 0 0 0 124
/**
 * This object represents a solid made entirely of triangles, which will only
 * be tested again z axis aligned rays
 */

557 8 LPoint3i 0 2048 8 LPoint3i 8 LPoint3i 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

558 16 CollisionPolygon 0 141313 16 CollisionPolygon 16 CollisionPolygon 0 0 0 1 396 403 3 712 713 714 6 397 398 399 400 401 402 1 746 0 1 0 552 0 0 0 0 10
/**
 *
 */

559 21 CollisionHandlerEvent 0 141313 21 CollisionHandlerEvent 21 CollisionHandlerEvent 0 0 0 1 404 423 3 715 716 717 18 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 3 747 748 749 0 1 0 531 0 0 0 0 296
/**
 * A specialized kind of CollisionHandler that throws an event for each
 * collision detected.  The event thrown may be based on the name of the
 * moving object or the struck object, or both.  The first parameter of the
 * event will be a pointer to the CollisionEntry that triggered it.
 */

560 6 string 0 2105344 11 std::string 11 std::string 0 0 561 0 0 0 0 0 0 0 0 0 0

561 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

562 24 CollisionHandlerPhysical 0 75777 24 CollisionHandlerPhysical 24 CollisionHandlerPhysical 0 0 0 0 423 1 718 10 424 425 426 427 428 429 430 431 432 433 0 0 1 0 559 0 0 0 0 209
/**
 * The abstract base class for a number of CollisionHandlers that have some
 * physical effect on their moving bodies: they need to update the nodes'
 * positions based on the effects of the collision.
 */

563 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 542 0 0 0 0 0 0 0 0 0 0

564 21 CollisionHandlerFloor 0 75777 21 CollisionHandlerFloor 21 CollisionHandlerFloor 0 0 0 1 434 423 3 719 720 721 7 435 436 437 438 439 440 441 0 0 1 0 562 0 0 0 0 294
/**
 * A specialized kind of CollisionHandler that sets the Z height of the
 * collider to a fixed linear offset from the highest detected collision point
 * each frame.  It's intended to implement walking around on a floor of
 * varying height by casting a ray down from the avatar's head.
 */

565 22 CollisionHandlerPusher 0 75777 22 CollisionHandlerPusher 22 CollisionHandlerPusher 0 0 0 1 442 423 1 722 3 443 444 445 0 0 1 0 562 0 0 0 0 197
/**
 * A specialized kind of CollisionHandler that simply pushes back on things
 * that attempt to move into solid walls.  This is the simplest kind of "real-
 * world" collisions you can have.
 */

566 27 CollisionHandlerFluidPusher 0 141313 27 CollisionHandlerFluidPusher 27 CollisionHandlerFluidPusher 0 0 0 1 446 448 0 1 447 0 0 1 0 565 0 0 0 0 139
/**
 * A CollisionHandlerPusher that makes use of timing and spatial information
 * from fluid collisions to improve collision response
 */

567 23 CollisionHandlerGravity 0 75777 23 CollisionHandlerGravity 23 CollisionHandlerGravity 0 0 0 1 449 423 9 723 724 725 726 727 728 729 730 731 18 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 0 0 1 0 562 0 0 0 0 294
/**
 * A specialized kind of CollisionHandler that sets the Z height of the
 * collider to a fixed linear offset from the highest detected collision point
 * each frame.  It's intended to implement walking around on a floor of
 * varying height by casting a ray down from the avatar's head.
 */

568 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 526 0 0 0 0 0 0 0 0 0 0

569 28 CollisionHandlerHighestEvent 0 141313 28 CollisionHandlerHighestEvent 28 CollisionHandlerHighestEvent 0 0 0 1 468 470 0 1 469 0 0 1 0 559 0 0 0 0 296
/**
 * A specialized kind of CollisionHandler that throws an event for each
 * collision detected.  The event thrown may be based on the name of the
 * moving object or the struck object, or both.  The first parameter of the
 * event will be a pointer to the CollisionEntry that triggered it.
 */

570 21 CollisionHandlerQueue 0 141313 21 CollisionHandlerQueue 21 CollisionHandlerQueue 0 0 0 1 471 479 1 732 7 472 473 474 475 476 477 478 1 750 0 1 0 531 0 0 0 0 313
/**
 * A special kind of CollisionHandler that does nothing except remember the
 * CollisionEntries detected the last pass.  This set of CollisionEntries may
 * then be queried by the calling function.  It's primarily useful when a
 * simple intersection test is being made, e.g.  for picking from the window.
 */

571 16 CollisionEntry * 0 8576 16 CollisionEntry * 16 CollisionEntry * 0 0 546 0 0 0 0 0 0 0 0 0 0

572 15 CollisionSphere 0 141313 15 CollisionSphere 15 CollisionSphere 0 0 0 1 480 486 2 733 734 5 481 482 483 484 485 0 0 1 0 518 0 0 0 0 50
/**
 * A spherical collision volume or object.
 */

573 18 CollisionInvSphere 0 141313 18 CollisionInvSphere 18 CollisionInvSphere 0 0 0 1 487 489 0 1 488 0 0 1 0 572 0 0 0 0 272
/**
 * An inverted sphere: this is a sphere whose collision surface is the inside
 * surface of the sphere.  Everything outside the sphere is solid matter;
 * everything inside is empty space.  Useful for constraining objects to
 * remain within a spherical perimeter.
 */

574 12 CollisionRay 0 141313 12 CollisionRay 12 CollisionRay 0 0 0 1 490 497 2 735 736 6 491 492 493 494 495 496 0 0 1 0 518 0 0 0 0 220
/**
 * An infinite ray, with a specific origin and direction.  It begins at its
 * origin and continues in one direction to infinity, and it has no radius.
 * Useful for picking from a window, or for gravity effects.
 */

575 13 CollisionLine 0 141313 13 CollisionLine 13 CollisionLine 0 0 0 1 498 500 0 1 499 0 0 1 0 574 0 0 0 0 131
/**
 * An infinite line, similar to a CollisionRay, except that it extends in both
 * directions.  It is, however, directional.
 */

576 17 CollisionParabola 0 141313 17 CollisionParabola 17 CollisionParabola 0 0 0 1 501 509 3 737 738 739 7 502 503 504 505 506 507 508 0 0 1 0 518 0 0 0 0 308
/**
 * This defines a parabolic arc, or subset of an arc, similar to the path of a
 * projectile or falling object.  It is finite, having a specific beginning
 * and end, but it is infinitely thin.
 *
 * Think of it as a wire bending from point t1 to point t2 along the path of a
 * pre-defined parabola.
 */

577 15 LParabola const 0 8832 15 LParabola const 15 LParabola const 0 0 578 0 0 0 0 0 0 0 0 0 0

578 9 LParabola 0 2105344 9 LParabola 9 LParabola 0 0 579 0 0 0 0 0 0 0 0 0 0

579 10 LParabolaf 0 2048 10 LParabolaf 10 LParabolaf 0 0 0 0 0 0 0 0 0 0 0 0 200
/**
 * An abstract mathematical description of a parabola, particularly useful for
 * describing arcs of projectiles.
 *
 * The parabolic equation, given parametrically here, is P = At^2 + Bt + C.
 */

580 16 CollisionSegment 0 141313 16 CollisionSegment 16 CollisionSegment 0 0 0 1 510 517 2 740 741 6 511 512 513 514 515 516 0 0 1 0 518 0 0 0 0 371
/**
 * A finite line segment, with two specific endpoints but no thickness.  It's
 * similar to a CollisionRay, except it does not continue to infinity.
 *
 * It does have an ordering, from point A to point B. If more than a single
 * point of the segment is intersecting a solid, the reported intersection
 * point is generally the closest on the segment to point A.
 */

581 13 CollisionTube 0 2105345 13 CollisionTube 13 CollisionTube 0 0 528 0 0 0 0 0 0 0 0 0 0

582 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 520 0 0 0 0 0 0 0 0 0 0

583 16 CollisionSolid * 0 8576 16 CollisionSolid * 16 CollisionSolid * 0 0 518 0 0 0 0 0 0 0 0 0 0

584 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

585 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 568 0 0 0 0 0 0 0 0 0 0

586 20 BoundingVolume const 0 8832 20 BoundingVolume const 20 BoundingVolume const 0 0 587 0 0 0 0 0 0 0 0 0 0

587 14 BoundingVolume 0 2048 14 BoundingVolume 14 BoundingVolume 0 0 0 0 0 0 0 0 0 0 0 0 330
/**
 * This is an abstract class for any volume in any sense which can be said to
 * define the locality of reference of a node in a graph, along with all of
 * its descendants.  It is not necessarily a geometric volume (although see
 * GeometricBoundingVolume); this is simply an abstract interface for bounds
 * of any sort.
 */

588 22 BoundingVolume const * 0 8576 22 BoundingVolume const * 22 BoundingVolume const * 0 0 586 0 0 0 0 0 0 0 0 0 0

589 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 590 0 0 0 0 0 0 0 0 0 0

590 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

591 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

592 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 591 0 0 0 0 0 0 0 0 0 0

593 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 525 0 0 0 0 0 0 0 0 0 0

594 14 CollisionBox * 0 8576 14 CollisionBox * 14 CollisionBox * 0 0 524 0 0 0 0 0 0 0 0 0 0

595 20 CollisionBox const * 0 8576 20 CollisionBox const * 20 CollisionBox const * 0 0 596 0 0 0 0 0 0 0 0 0 0

596 18 CollisionBox const 0 8832 18 CollisionBox const 18 CollisionBox const 0 0 524 0 0 0 0 0 0 0 0 0 0

597 8 LPlane * 0 8576 8 LPlane * 8 LPlane * 0 0 554 0 0 0 0 0 0 0 0 0 0

598 10 LVector3 * 0 8576 10 LVector3 * 10 LVector3 * 0 0 526 0 0 0 0 0 0 0 0 0 0

599 18 CollisionCapsule * 0 8576 18 CollisionCapsule * 18 CollisionCapsule * 0 0 528 0 0 0 0 0 0 0 0 0 0

600 24 CollisionCapsule const * 0 8576 24 CollisionCapsule const * 24 CollisionCapsule const * 0 0 601 0 0 0 0 0 0 0 0 0 0

601 22 CollisionCapsule const 0 8832 22 CollisionCapsule const 22 CollisionCapsule const 0 0 528 0 0 0 0 0 0 0 0 0 0

602 24 CollisionHandler const * 0 8576 24 CollisionHandler const * 24 CollisionHandler const * 0 0 603 0 0 0 0 0 0 0 0 0 0

603 22 CollisionHandler const 0 8832 22 CollisionHandler const 22 CollisionHandler const 0 0 531 0 0 0 0 0 0 0 0 0 0

604 18 CollisionHandler * 0 8576 18 CollisionHandler * 18 CollisionHandler * 0 0 531 0 0 0 0 0 0 0 0 0 0

605 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

606 13 CollideMask * 0 8576 13 CollideMask * 13 CollideMask * 0 0 535 0 0 0 0 0 0 0 0 0 0

607 21 CollisionNode const * 0 8576 21 CollisionNode const * 21 CollisionNode const * 0 0 608 0 0 0 0 0 0 0 0 0 0

608 19 CollisionNode const 0 8832 19 CollisionNode const 19 CollisionNode const 0 0 533 0 0 0 0 0 0 0 0 0 0

609 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 610 0 0 0 0 0 0 0 0 0 0

610 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

611 26 CollisionTraverser const * 0 8576 26 CollisionTraverser const * 26 CollisionTraverser const * 0 0 612 0 0 0 0 0 0 0 0 0 0

612 24 CollisionTraverser const 0 8832 24 CollisionTraverser const 24 CollisionTraverser const 0 0 540 0 0 0 0 0 0 0 0 0 0

613 20 CollisionTraverser * 0 8576 20 CollisionTraverser * 20 CollisionTraverser * 0 0 540 0 0 0 0 0 0 0 0 0 0

614 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 563 0 0 0 0 0 0 0 0 0 0

615 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 542 0 0 0 0 0 0 0 0 0 0

616 25 CollisionRecorder const * 0 8576 25 CollisionRecorder const * 25 CollisionRecorder const * 0 0 617 0 0 0 0 0 0 0 0 0 0

617 23 CollisionRecorder const 0 8832 23 CollisionRecorder const 23 CollisionRecorder const 0 0 544 0 0 0 0 0 0 0 0 0 0

618 22 CollisionEntry const * 0 8576 22 CollisionEntry const * 22 CollisionEntry const * 0 0 619 0 0 0 0 0 0 0 0 0 0

619 20 CollisionEntry const 0 8832 20 CollisionEntry const 20 CollisionEntry const 0 0 546 0 0 0 0 0 0 0 0 0 0

620 22 CollisionPlane const * 0 8576 22 CollisionPlane const * 22 CollisionPlane const * 0 0 621 0 0 0 0 0 0 0 0 0 0

621 20 CollisionPlane const 0 8832 20 CollisionPlane const 20 CollisionPlane const 0 0 552 0 0 0 0 0 0 0 0 0 0

622 16 CollisionPlane * 0 8576 16 CollisionPlane * 16 CollisionPlane * 0 0 552 0 0 0 0 0 0 0 0 0 0

623 14 LPlane const * 0 8576 14 LPlane const * 14 LPlane const * 0 0 553 0 0 0 0 0 0 0 0 0 0

624 20 CollisionFloorMesh * 0 8576 20 CollisionFloorMesh * 20 CollisionFloorMesh * 0 0 556 0 0 0 0 0 0 0 0 0 0

625 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

626 26 CollisionFloorMesh const * 0 8576 26 CollisionFloorMesh const * 26 CollisionFloorMesh const * 0 0 627 0 0 0 0 0 0 0 0 0 0

627 24 CollisionFloorMesh const 0 8832 24 CollisionFloorMesh const 24 CollisionFloorMesh const 0 0 556 0 0 0 0 0 0 0 0 0 0

628 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 557 0 0 0 0 0 0 0 0 0 0

629 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 630 0 0 0 0 0 0 0 0 0 0

630 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 631 0 0 0 0 0 0 0 0 0 0

631 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 632 0 0 0 0 0 0 0 0 0 0

632 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

633 18 CollisionPolygon * 0 8576 18 CollisionPolygon * 18 CollisionPolygon * 0 0 558 0 0 0 0 0 0 0 0 0 0

634 24 CollisionPolygon const * 0 8576 24 CollisionPolygon const * 24 CollisionPolygon const * 0 0 635 0 0 0 0 0 0 0 0 0 0

635 22 CollisionPolygon const 0 8832 22 CollisionPolygon const 22 CollisionPolygon const 0 0 558 0 0 0 0 0 0 0 0 0 0

636 23 CollisionHandlerEvent * 0 8576 23 CollisionHandlerEvent * 23 CollisionHandlerEvent * 0 0 559 0 0 0 0 0 0 0 0 0 0

637 29 CollisionHandlerEvent const * 0 8576 29 CollisionHandlerEvent const * 29 CollisionHandlerEvent const * 0 0 638 0 0 0 0 0 0 0 0 0 0

638 27 CollisionHandlerEvent const 0 8832 27 CollisionHandlerEvent const 27 CollisionHandlerEvent const 0 0 559 0 0 0 0 0 0 0 0 0 0

639 26 CollisionHandlerPhysical * 0 8576 26 CollisionHandlerPhysical * 26 CollisionHandlerPhysical * 0 0 562 0 0 0 0 0 0 0 0 0 0

640 16 DriveInterface * 0 8576 16 DriveInterface * 16 DriveInterface * 0 0 641 0 0 0 0 0 0 0 0 0 0

641 14 DriveInterface 0 2048 14 DriveInterface 14 DriveInterface 0 0 0 0 0 0 0 0 0 0 0 0 191
/**
 * This is a TFormer, similar to Trackball, that moves around a transform
 * matrix in response to mouse input.  The basic motion is on a horizontal
 * plane, as if driving a vehicle.
 */

642 32 CollisionHandlerPhysical const * 0 8576 32 CollisionHandlerPhysical const * 32 CollisionHandlerPhysical const * 0 0 643 0 0 0 0 0 0 0 0 0 0

643 30 CollisionHandlerPhysical const 0 8832 30 CollisionHandlerPhysical const 30 CollisionHandlerPhysical const 0 0 562 0 0 0 0 0 0 0 0 0 0

644 23 CollisionHandlerFloor * 0 8576 23 CollisionHandlerFloor * 23 CollisionHandlerFloor * 0 0 564 0 0 0 0 0 0 0 0 0 0

645 29 CollisionHandlerFloor const * 0 8576 29 CollisionHandlerFloor const * 29 CollisionHandlerFloor const * 0 0 646 0 0 0 0 0 0 0 0 0 0

646 27 CollisionHandlerFloor const 0 8832 27 CollisionHandlerFloor const 27 CollisionHandlerFloor const 0 0 564 0 0 0 0 0 0 0 0 0 0

647 24 CollisionHandlerPusher * 0 8576 24 CollisionHandlerPusher * 24 CollisionHandlerPusher * 0 0 565 0 0 0 0 0 0 0 0 0 0

648 30 CollisionHandlerPusher const * 0 8576 30 CollisionHandlerPusher const * 30 CollisionHandlerPusher const * 0 0 649 0 0 0 0 0 0 0 0 0 0

649 28 CollisionHandlerPusher const 0 8832 28 CollisionHandlerPusher const 28 CollisionHandlerPusher const 0 0 565 0 0 0 0 0 0 0 0 0 0

650 29 CollisionHandlerFluidPusher * 0 8576 29 CollisionHandlerFluidPusher * 29 CollisionHandlerFluidPusher * 0 0 566 0 0 0 0 0 0 0 0 0 0

651 25 CollisionHandlerGravity * 0 8576 25 CollisionHandlerGravity * 25 CollisionHandlerGravity * 0 0 567 0 0 0 0 0 0 0 0 0 0

652 31 CollisionHandlerGravity const * 0 8576 31 CollisionHandlerGravity const * 31 CollisionHandlerGravity const * 0 0 653 0 0 0 0 0 0 0 0 0 0

653 29 CollisionHandlerGravity const 0 8832 29 CollisionHandlerGravity const 29 CollisionHandlerGravity const 0 0 567 0 0 0 0 0 0 0 0 0 0

654 30 CollisionHandlerHighestEvent * 0 8576 30 CollisionHandlerHighestEvent * 30 CollisionHandlerHighestEvent * 0 0 569 0 0 0 0 0 0 0 0 0 0

655 36 CollisionHandlerHighestEvent const * 0 8576 36 CollisionHandlerHighestEvent const * 36 CollisionHandlerHighestEvent const * 0 0 656 0 0 0 0 0 0 0 0 0 0

656 34 CollisionHandlerHighestEvent const 0 8832 34 CollisionHandlerHighestEvent const 34 CollisionHandlerHighestEvent const 0 0 569 0 0 0 0 0 0 0 0 0 0

657 23 CollisionHandlerQueue * 0 8576 23 CollisionHandlerQueue * 23 CollisionHandlerQueue * 0 0 570 0 0 0 0 0 0 0 0 0 0

658 29 CollisionHandlerQueue const * 0 8576 29 CollisionHandlerQueue const * 29 CollisionHandlerQueue const * 0 0 659 0 0 0 0 0 0 0 0 0 0

659 27 CollisionHandlerQueue const 0 8832 27 CollisionHandlerQueue const 27 CollisionHandlerQueue const 0 0 570 0 0 0 0 0 0 0 0 0 0

660 17 CollisionSphere * 0 8576 17 CollisionSphere * 17 CollisionSphere * 0 0 572 0 0 0 0 0 0 0 0 0 0

661 23 CollisionSphere const * 0 8576 23 CollisionSphere const * 23 CollisionSphere const * 0 0 662 0 0 0 0 0 0 0 0 0 0

662 21 CollisionSphere const 0 8832 21 CollisionSphere const 21 CollisionSphere const 0 0 572 0 0 0 0 0 0 0 0 0 0

663 20 CollisionInvSphere * 0 8576 20 CollisionInvSphere * 20 CollisionInvSphere * 0 0 573 0 0 0 0 0 0 0 0 0 0

664 14 CollisionRay * 0 8576 14 CollisionRay * 14 CollisionRay * 0 0 574 0 0 0 0 0 0 0 0 0 0

665 20 CollisionRay const * 0 8576 20 CollisionRay const * 20 CollisionRay const * 0 0 666 0 0 0 0 0 0 0 0 0 0

666 18 CollisionRay const 0 8832 18 CollisionRay const 18 CollisionRay const 0 0 574 0 0 0 0 0 0 0 0 0 0

667 10 LensNode * 0 8576 10 LensNode * 10 LensNode * 0 0 668 0 0 0 0 0 0 0 0 0 0

668 8 LensNode 0 2048 8 LensNode 8 LensNode 0 0 0 0 0 0 0 0 0 0 0 0 181
/**
 * A node that contains a Lens.  The most important example of this kind of
 * node is a Camera, but other kinds of nodes also contain a lens (for
 * instance, a Spotlight).
 */

669 15 LPoint2 const * 0 8576 15 LPoint2 const * 15 LPoint2 const * 0 0 670 0 0 0 0 0 0 0 0 0 0

670 13 LPoint2 const 0 8832 13 LPoint2 const 13 LPoint2 const 0 0 671 0 0 0 0 0 0 0 0 0 0

671 7 LPoint2 0 2105344 7 LPoint2 7 LPoint2 0 0 672 0 0 0 0 0 0 0 0 0 0

672 8 LPoint2f 0 2048 8 LPoint2f 8 LPoint2f 0 0 0 0 0 0 0 0 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

673 15 CollisionLine * 0 8576 15 CollisionLine * 15 CollisionLine * 0 0 575 0 0 0 0 0 0 0 0 0 0

674 19 CollisionParabola * 0 8576 19 CollisionParabola * 19 CollisionParabola * 0 0 576 0 0 0 0 0 0 0 0 0 0

675 17 LParabola const * 0 8576 17 LParabola const * 17 LParabola const * 0 0 577 0 0 0 0 0 0 0 0 0 0

676 25 CollisionParabola const * 0 8576 25 CollisionParabola const * 25 CollisionParabola const * 0 0 677 0 0 0 0 0 0 0 0 0 0

677 23 CollisionParabola const 0 8832 23 CollisionParabola const 23 CollisionParabola const 0 0 576 0 0 0 0 0 0 0 0 0 0

678 18 CollisionSegment * 0 8576 18 CollisionSegment * 18 CollisionSegment * 0 0 580 0 0 0 0 0 0 0 0 0 0

679 24 CollisionSegment const * 0 8576 24 CollisionSegment const * 24 CollisionSegment const * 0 0 680 0 0 0 0 0 0 0 0 0 0

680 22 CollisionSegment const 0 8832 22 CollisionSegment const 22 CollisionSegment const 0 0 580 0 0 0 0 0 0 0 0 0 0

0
61
681 16 collision_origin 0 2 520 265 0 0 0 0 0 0 0 32 CollisionSolid::collision_origin 0

682 8 tangible 0 6 522 267 266 0 0 0 0 0 0 24 CollisionSolid::tangible 0

683 24 respect_effective_normal 0 6 522 273 272 0 0 0 0 0 0 40 CollisionSolid::respect_effective_normal 0

684 6 bounds 0 6 523 274 275 0 0 0 0 0 0 22 CollisionSolid::bounds 0

685 6 center 0 2 525 287 0 0 0 0 0 0 0 20 CollisionBox::center 0

686 3 min 0 2 525 288 0 0 0 0 0 0 0 17 CollisionBox::min 0

687 3 max 0 2 525 289 0 0 0 0 0 0 0 17 CollisionBox::max 0

688 10 dimensions 0 2 526 290 0 0 0 0 0 0 0 24 CollisionBox::dimensions 0

689 7 point_a 0 6 525 295 294 0 0 0 0 0 0 25 CollisionCapsule::point_a 0

690 7 point_b 0 6 525 297 296 0 0 0 0 0 0 25 CollisionCapsule::point_b 0

691 6 radius 0 6 529 299 298 0 0 0 0 0 0 24 CollisionCapsule::radius 0

692 17 from_collide_mask 0 6 535 309 307 0 0 0 0 0 0 32 CollisionNode::from_collide_mask 0

693 17 into_collide_mask 0 6 535 310 308 0 0 0 0 0 0 32 CollisionNode::into_collide_mask 0

694 6 solids 0 358 538 313 315 0 0 317 312 316 0 21 CollisionNode::solids 0

695 13 collider_sort 0 6 539 319 320 0 0 0 0 0 0 28 CollisionNode::collider_sort 0

696 20 default_collide_mask 0 2 535 321 0 0 0 0 0 0 0 35 CollisionNode::default_collide_mask 0

697 22 respect_prev_transform 0 6 522 326 325 0 0 0 0 0 0 42 CollisionTraverser::respect_prev_transform 0

698 9 colliders 0 66 542 331 0 0 0 0 330 0 0 29 CollisionTraverser::colliders 0

699 8 recorder 0 30 543 337 335 336 338 0 0 0 0 28 CollisionTraverser::recorder 0

700 10 from_solid 0 2 548 346 0 0 0 0 0 0 0 26 CollisionEntry::from_solid 0

701 10 into_solid 0 2 548 348 0 0 0 0 0 0 0 26 CollisionEntry::into_solid 0

702 9 from_node 0 2 550 349 0 0 0 0 0 0 0 25 CollisionEntry::from_node 0

703 9 into_node 0 2 551 350 0 0 0 0 0 0 0 25 CollisionEntry::into_node 0

704 14 from_node_path 0 2 542 351 0 0 0 0 0 0 0 30 CollisionEntry::from_node_path 0

705 14 into_node_path 0 2 542 352 0 0 0 0 0 0 0 30 CollisionEntry::into_node_path 0

706 1 t 0 6 529 354 353 0 0 0 0 0 0 17 CollisionEntry::t 0

707 22 respect_prev_transform 0 2 522 357 0 0 0 0 0 0 0 38 CollisionEntry::respect_prev_transform 0

708 6 normal 0 2 526 380 0 0 0 0 0 0 0 22 CollisionPlane::normal 0

709 5 plane 0 6 553 383 382 0 0 0 0 0 0 21 CollisionPlane::plane 0

710 8 vertices 0 66 525 391 0 0 0 0 390 0 0 28 CollisionFloorMesh::vertices 0

711 9 triangles 0 66 557 393 0 0 0 0 392 0 0 29 CollisionFloorMesh::triangles 0

712 6 points 0 66 520 398 0 0 0 0 397 0 0 24 CollisionPolygon::points 0

713 5 valid 0 2 522 400 0 0 0 0 0 0 0 23 CollisionPolygon::valid 0

714 7 concave 0 2 522 401 0 0 0 0 0 0 0 25 CollisionPolygon::concave 0

715 11 in_patterns 0 66 560 409 0 0 0 0 408 0 0 34 CollisionHandlerEvent::in_patterns 0

716 14 again_patterns 0 66 560 419 0 0 0 0 413 0 0 37 CollisionHandlerEvent::again_patterns 0

717 12 out_patterns 0 66 560 419 0 0 0 0 418 0 0 35 CollisionHandlerEvent::out_patterns 0

718 6 center 0 30 563 430 428 431 429 0 0 0 0 32 CollisionHandlerPhysical::center 0

719 6 offset 0 6 529 436 435 0 0 0 0 0 0 29 CollisionHandlerFloor::offset 0

720 5 reach 0 6 529 438 437 0 0 0 0 0 0 28 CollisionHandlerFloor::reach 0

721 12 max_velocity 0 6 529 440 439 0 0 0 0 0 0 35 CollisionHandlerFloor::max_velocity 0

722 10 horizontal 0 6 522 444 443 0 0 0 0 0 0 34 CollisionHandlerPusher::horizontal 0

723 6 offset 0 6 529 451 450 0 0 0 0 0 0 31 CollisionHandlerGravity::offset 0

724 5 reach 0 6 529 453 452 0 0 0 0 0 0 30 CollisionHandlerGravity::reach 0

725 15 airborne_height 0 2 529 454 0 0 0 0 0 0 0 40 CollisionHandlerGravity::airborne_height 0

726 9 on_ground 0 2 522 455 0 0 0 0 0 0 0 34 CollisionHandlerGravity::on_ground 0

727 15 impact_velocity 0 2 529 456 0 0 0 0 0 0 0 40 CollisionHandlerGravity::impact_velocity 0

728 14 contact_normal 0 2 568 457 0 0 0 0 0 0 0 39 CollisionHandlerGravity::contact_normal 0

729 8 velocity 0 6 529 460 459 0 0 0 0 0 0 33 CollisionHandlerGravity::velocity 0

730 7 gravity 0 6 529 462 461 0 0 0 0 0 0 32 CollisionHandlerGravity::gravity 0

731 12 max_velocity 0 6 529 464 463 0 0 0 0 0 0 37 CollisionHandlerGravity::max_velocity 0

732 7 entries 0 66 571 475 0 0 0 0 474 0 0 30 CollisionHandlerQueue::entries 0

733 6 center 0 6 525 482 481 0 0 0 0 0 0 23 CollisionSphere::center 0

734 6 radius 0 6 529 484 483 0 0 0 0 0 0 23 CollisionSphere::radius 0

735 6 origin 0 6 525 492 491 0 0 0 0 0 0 20 CollisionRay::origin 0

736 9 direction 0 6 568 494 493 0 0 0 0 0 0 23 CollisionRay::direction 0

737 8 parabola 0 6 577 503 502 0 0 0 0 0 0 27 CollisionParabola::parabola 0

738 2 t1 0 6 529 505 504 0 0 0 0 0 0 21 CollisionParabola::t1 0

739 2 t2 0 6 529 507 506 0 0 0 0 0 0 21 CollisionParabola::t2 0

740 7 point_a 0 6 525 512 511 0 0 0 0 0 0 25 CollisionSegment::point_a 0

741 7 point_b 0 6 525 514 513 0 0 0 0 0 0 25 CollisionSegment::point_b 0

9
742 10 get_solids 0 312 313 25 CollisionNode::get_solids 0

743 13 get_colliders 0 330 331 33 CollisionTraverser::get_colliders 0

744 12 get_vertices 0 390 391 32 CollisionFloorMesh::get_vertices 0

745 13 get_triangles 0 392 393 33 CollisionFloorMesh::get_triangles 0

746 10 get_points 0 397 398 28 CollisionPolygon::get_points 0

747 15 get_in_patterns 0 408 409 38 CollisionHandlerEvent::get_in_patterns 0

748 18 get_again_patterns 0 413 414 41 CollisionHandlerEvent::get_again_patterns 0

749 16 get_out_patterns 0 418 419 39 CollisionHandlerEvent::get_out_patterns 0

750 11 get_entries 0 474 475 34 CollisionHandlerQueue::get_entries 0

